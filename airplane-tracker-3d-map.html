<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Airplane Tracker - Live ADS-B Data</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            transition: background 0.3s ease;
        }
        body.theme-day {
            background: #87CEEB;
            color: #333;
        }
        body.theme-night {
            background: #0a0a1a;
            color: #fff;
        }
        body.theme-retro {
            background: #000800;
            color: #00ff00;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            border-radius: 12px;
            min-width: 280px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .theme-day #info-panel {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #info-panel {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #info-panel {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        #info-panel h2 {
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        .theme-day #info-panel h2 { color: #0066cc; }
        .theme-night #info-panel h2 { color: #00d4ff; }
        .theme-retro #info-panel h2 { color: #00ff00; text-shadow: 0 0 10px #00ff00; }

        .stat {
            margin: 8px 0;
            font-size: 0.95em;
        }
        .stat-label {
            opacity: 0.7;
        }
        .stat-value {
            font-weight: bold;
        }
        .theme-day .stat-value { color: #00aa44; }
        .theme-night .stat-value { color: #00ff88; }
        .theme-retro .stat-value { color: #00ff00; text-shadow: 0 0 5px #00ff00; }

        #selected-plane {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 20px;
            border-radius: 12px;
            min-width: 300px;
            display: none;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .theme-day #selected-plane {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(255, 150, 0, 0.3);
        }
        .theme-night #selected-plane {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(255, 150, 0, 0.3);
        }
        .theme-retro #selected-plane {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
        }
        #selected-plane h3 {
            margin-bottom: 15px;
        }
        .theme-day #selected-plane h3 { color: #cc6600; }
        .theme-night #selected-plane h3 { color: #ffaa00; }
        .theme-retro #selected-plane h3 { color: #00ff00; }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            border-radius: 30px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            max-width: 95vw;
            transition: all 0.3s ease;
        }
        .theme-day #controls {
            background: rgba(255, 255, 255, 0.85);
        }
        .theme-night #controls {
            background: rgba(0, 20, 40, 0.85);
        }
        .theme-retro #controls {
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
        }

        button {
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        .theme-day button {
            background: linear-gradient(135deg, #0088ff, #0066cc);
            color: #fff;
        }
        .theme-night button {
            background: linear-gradient(135deg, #0066cc, #0044aa);
            color: #fff;
        }
        .theme-retro button {
            background: transparent;
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        button:hover {
            transform: scale(1.05);
        }
        .theme-retro button:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        button.active {
            background: #00aa00 !important;
        }
        .theme-retro button.active {
            background: rgba(0, 255, 0, 0.3) !important;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid rgba(128, 128, 128, 0.3);
        }
        .control-group:last-child {
            border-right: none;
        }
        .control-label {
            font-size: 0.75em;
            opacity: 0.7;
            margin-right: 5px;
        }

        /* Trail controls - inline in controls */
        .trail-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .trail-control input[type="range"] {
            width: 60px;
            height: 6px;
            cursor: pointer;
        }
        #trail-length-value {
            font-size: 0.75em;
            min-width: 25px;
        }

        /* Altitude slider - inline in controls */
        .altitude-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #altitude-slider {
            width: 80px;
            height: 6px;
            cursor: pointer;
        }
        #altitude-value {
            font-weight: bold;
            font-size: 0.8em;
            min-width: 35px;
        }

        /* Graphs Panel Styles */
        #graphs-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 320px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: none;
        }
        #graphs-panel.visible {
            display: block;
        }
        .theme-day #graphs-panel {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #graphs-panel {
            background: rgba(0, 20, 40, 0.92);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #graphs-panel {
            background: rgba(0, 20, 0, 0.95);
            border: 1px solid #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        #graphs-panel h3 {
            margin-bottom: 12px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .theme-day #graphs-panel h3 { color: #0066cc; }
        .theme-night #graphs-panel h3 { color: #00d4ff; }
        .theme-retro #graphs-panel h3 { color: #00ff00; text-shadow: 0 0 10px #00ff00; }

        .time-period-selector {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        .time-period-btn {
            flex: 1;
            min-width: 45px;
            padding: 6px 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .theme-day .time-period-btn {
            background: rgba(0, 100, 200, 0.15);
            color: #0066cc;
        }
        .theme-day .time-period-btn:hover {
            background: rgba(0, 100, 200, 0.25);
        }
        .theme-day .time-period-btn.active {
            background: #0088ff;
            color: #fff;
        }
        .theme-night .time-period-btn {
            background: rgba(0, 150, 255, 0.2);
            color: #00d4ff;
        }
        .theme-night .time-period-btn:hover {
            background: rgba(0, 150, 255, 0.35);
        }
        .theme-night .time-period-btn.active {
            background: #0088ff;
            color: #fff;
        }
        .theme-retro .time-period-btn {
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        .theme-retro .time-period-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }
        .theme-retro .time-period-btn.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .graphs1090-status {
            font-size: 0.7em;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: normal;
        }
        .graphs1090-status.connected {
            background: rgba(0, 200, 100, 0.3);
            color: #00cc66;
        }
        .graphs1090-status.local {
            background: rgba(255, 150, 0, 0.3);
            color: #ffaa00;
        }

        /* Data source status indicator */
        .data-status {
            font-size: 0.7em;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: normal;
            margin-left: 5px;
        }
        .data-status.connected {
            background: rgba(0, 200, 100, 0.3);
            color: #00cc66;
        }
        .data-status.connecting {
            background: rgba(255, 150, 0, 0.3);
            color: #ffaa00;
            animation: pulse 1s infinite;
        }
        .data-status.error {
            background: rgba(255, 50, 50, 0.3);
            color: #ff4444;
        }
        .theme-retro .data-status.connected {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
        .theme-retro .data-status.connecting {
            background: rgba(0, 255, 0, 0.1);
            color: #00cc00;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Radius slider styles */
        #radius-slider {
            width: 80px;
            cursor: pointer;
        }
        #radius-value {
            font-size: 0.75em;
            min-width: 50px;
            margin-left: 5px;
        }

        .graph-card {
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .theme-day .graph-card {
            background: rgba(0, 100, 200, 0.1);
        }
        .theme-night .graph-card {
            background: rgba(0, 100, 200, 0.2);
        }
        .theme-retro .graph-card {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .graph-card h4 {
            font-size: 0.85em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .graph-current-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .theme-day .graph-current-value { color: #0088ff; }
        .theme-night .graph-current-value { color: #00d4ff; }
        .theme-retro .graph-current-value { color: #00ff00; text-shadow: 0 0 8px #00ff00; }

        .graph-canvas-container {
            width: 100%;
            height: 60px;
            border-radius: 4px;
            overflow: hidden;
        }
        .theme-day .graph-canvas-container {
            background: rgba(0, 0, 0, 0.05);
        }
        .theme-night .graph-canvas-container {
            background: rgba(0, 0, 0, 0.3);
        }
        .theme-retro .graph-canvas-container {
            background: rgba(0, 50, 0, 0.5);
        }

        .graph-canvas {
            width: 100%;
            height: 100%;
        }

        .graph-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            margin-top: 6px;
            opacity: 0.7;
        }

        #graphs-panel::-webkit-scrollbar {
            width: 6px;
        }
        #graphs-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        .theme-day #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 100, 200, 0.3);
            border-radius: 3px;
        }
        .theme-night #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 150, 255, 0.3);
            border-radius: 3px;
        }
        .theme-retro #graphs-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 0, 0.3);
            border-radius: 3px;
        }

        select {
            padding: 6px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .theme-day select {
            background: #fff;
            border: 1px solid #ccc;
            color: #333;
        }
        .theme-night select {
            background: #1a3a5a;
            border: 1px solid #0066cc;
            color: #fff;
        }
        .theme-retro select {
            background: #001a00;
            border: 1px solid #00ff00;
            color: #00ff00;
        }

        /* Keyboard Shortcuts Help Overlay */
        #keyboard-help {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        #keyboard-help.visible {
            display: flex;
        }
        #keyboard-help-content {
            background: rgba(20, 40, 60, 0.95);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #keyboard-help-content {
            background: rgba(0, 20, 0, 0.95);
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        #keyboard-help h2 {
            margin-bottom: 20px;
            color: #00d4ff;
            text-align: center;
        }
        .theme-retro #keyboard-help h2 {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        .shortcut-group {
            margin-bottom: 20px;
        }
        .shortcut-group h3 {
            color: #88ccff;
            margin-bottom: 10px;
            font-size: 0.95em;
            border-bottom: 1px solid rgba(100, 150, 200, 0.3);
            padding-bottom: 5px;
        }
        .theme-retro .shortcut-group h3 {
            color: #00cc00;
            border-color: rgba(0, 255, 0, 0.3);
        }
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 0.9em;
        }
        .shortcut-key {
            background: rgba(0, 100, 200, 0.3);
            padding: 3px 10px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        .theme-retro .shortcut-key {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
        .shortcut-desc {
            color: #ccc;
        }
        .theme-retro .shortcut-desc {
            color: #00cc00;
        }
        #keyboard-help .close-hint {
            text-align: center;
            margin-top: 20px;
            opacity: 0.6;
            font-size: 0.85em;
        }

        /* Enhanced Stats - integrated into info panel */
        #stats-section {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(128, 128, 128, 0.3);
        }
        #stats-section.visible {
            display: block;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .stats-item {
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        .theme-day .stats-item { background: rgba(0, 100, 200, 0.1); }
        .theme-night .stats-item { background: rgba(0, 100, 200, 0.2); }
        .theme-retro .stats-item { background: rgba(0, 255, 0, 0.1); border: 1px solid rgba(0, 255, 0, 0.3); }
        .stats-item .value {
            font-size: 1.4em;
            font-weight: bold;
            display: block;
        }
        .theme-day .stats-item .value { color: #0088ff; }
        .theme-night .stats-item .value { color: #00d4ff; }
        .theme-retro .stats-item .value { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
        .stats-item .label {
            font-size: 0.75em;
            opacity: 0.7;
        }
        .coverage-map {
            width: 100%;
            height: 120px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .theme-day .coverage-map { background: rgba(0, 0, 0, 0.05); }
        .theme-night .coverage-map { background: rgba(0, 0, 0, 0.3); }
        .theme-retro .coverage-map { background: rgba(0, 50, 0, 0.5); border: 1px solid rgba(0, 255, 0, 0.3); }
        .altitude-distribution {
            margin-top: 10px;
        }
        .altitude-bar {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 0.75em;
        }
        .altitude-bar .label {
            width: 60px;
            text-align: right;
            margin-right: 8px;
        }
        .altitude-bar .bar {
            flex: 1;
            height: 12px;
            border-radius: 3px;
            position: relative;
        }
        .theme-day .altitude-bar .bar { background: rgba(0, 100, 200, 0.2); }
        .theme-night .altitude-bar .bar { background: rgba(0, 100, 200, 0.3); }
        .theme-retro .altitude-bar .bar { background: rgba(0, 255, 0, 0.15); }
        .altitude-bar .fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        .altitude-bar .count {
            width: 30px;
            text-align: right;
            margin-left: 8px;
            font-weight: bold;
        }

        /* Aircraft Info Enrichment Panel */
        #aircraft-enriched-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(128, 128, 128, 0.3);
            display: none;
        }
        #aircraft-enriched-info.visible {
            display: block;
        }
        .enriched-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.85em;
        }
        .enriched-label {
            opacity: 0.7;
        }
        .enriched-value {
            font-weight: 500;
        }
        #aircraft-photo {
            width: 100%;
            max-height: 120px;
            object-fit: cover;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }
        .enriched-loading {
            text-align: center;
            padding: 10px;
            opacity: 0.6;
            font-size: 0.85em;
        }
        .external-links {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .external-link {
            font-size: 0.75em;
            padding: 4px 8px;
            border-radius: 4px;
            text-decoration: none;
            transition: all 0.2s;
        }
        .theme-day .external-link {
            background: rgba(0, 100, 200, 0.15);
            color: #0066cc;
        }
        .theme-night .external-link {
            background: rgba(0, 150, 255, 0.2);
            color: #00d4ff;
        }
        .theme-retro .external-link {
            background: rgba(0, 255, 0, 0.15);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        .external-link:hover {
            transform: scale(1.05);
        }

        /* Mobile Touch Optimization */
        @media (max-width: 768px) {
            #controls {
                padding: 10px 15px;
                gap: 6px;
                bottom: 10px;
            }
            .control-group {
                padding: 0 6px;
            }
            button {
                padding: 10px 14px;
                font-size: 0.9em;
                min-height: 44px;
            }
            select {
                padding: 10px 12px;
                font-size: 0.9em;
                min-height: 44px;
            }
            #info-panel {
                top: 10px;
                left: 10px;
                padding: 12px;
                min-width: 200px;
                font-size: 0.9em;
            }
            #selected-plane {
                top: 10px;
                right: 10px;
                padding: 12px;
                min-width: 220px;
                max-width: 45vw;
            }
            #graphs-panel {
                right: 10px;
                width: 280px;
                max-height: calc(100vh - 100px);
            }
            #altitude-slider {
                width: 60px;
            }
            .control-label {
                display: none;
            }
        }

        @media (max-width: 480px) {
            #controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            .control-group {
                border-right: none;
                border-bottom: 1px solid rgba(128, 128, 128, 0.2);
                padding: 5px;
                width: 100%;
                justify-content: center;
            }
            .control-group:last-child {
                border-bottom: none;
            }
            #info-panel h2 {
                font-size: 1.1em;
            }
            #selected-plane {
                max-width: 60vw;
            }
        }

        /* Touch feedback */
        @media (hover: none) and (pointer: coarse) {
            button:active, select:active {
                transform: scale(0.95);
                opacity: 0.8;
            }
        }

        /* Search & Filter Panel */
        #search-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
            z-index: 100;
            transition: all 0.3s ease;
        }
        .theme-day #search-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #search-panel {
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #search-panel {
            background: rgba(0, 20, 0, 0.95);
            border: 1px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        #search-panel.collapsed {
            padding: 8px 15px;
        }
        #search-panel.collapsed .search-filters {
            display: none;
        }
        #search-input {
            padding: 8px 15px;
            border-radius: 20px;
            border: none;
            font-size: 0.9em;
            width: 180px;
            outline: none;
        }
        .theme-day #search-input {
            background: rgba(0, 100, 200, 0.1);
            color: #333;
        }
        .theme-night #search-input {
            background: rgba(0, 100, 200, 0.3);
            color: #fff;
        }
        .theme-retro #search-input {
            background: rgba(0, 50, 0, 0.8);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.5);
        }
        #search-input::placeholder {
            opacity: 0.6;
        }
        .theme-retro #search-input::placeholder {
            color: #00aa00;
        }
        .search-filters {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
        }
        .filter-group label {
            opacity: 0.7;
        }
        .filter-group select, .filter-group input {
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 0.85em;
        }
        .theme-day .filter-group select, .theme-day .filter-group input {
            background: rgba(0, 100, 200, 0.1);
            border: 1px solid rgba(0, 100, 200, 0.2);
            color: #333;
        }
        .theme-night .filter-group select, .theme-night .filter-group input {
            background: rgba(0, 100, 200, 0.3);
            border: 1px solid rgba(0, 100, 200, 0.3);
            color: #fff;
        }
        .theme-retro .filter-group select, .theme-retro .filter-group input {
            background: rgba(0, 50, 0, 0.8);
            border: 1px solid rgba(0, 255, 0, 0.5);
            color: #00ff00;
        }
        #search-results-count {
            font-size: 0.8em;
            padding: 4px 10px;
            border-radius: 10px;
            min-width: 60px;
            text-align: center;
        }
        .theme-day #search-results-count {
            background: rgba(0, 150, 100, 0.2);
            color: #006644;
        }
        .theme-night #search-results-count {
            background: rgba(0, 200, 150, 0.2);
            color: #00ffaa;
        }
        .theme-retro #search-results-count {
            background: rgba(0, 255, 0, 0.15);
            color: #00ff00;
        }
        #search-clear {
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.8em;
        }
        #search-toggle {
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* Custom Map Tile Layer Panel */
        #tile-layer-panel {
            position: absolute;
            bottom: 100px;
            left: 20px;
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: none;
            max-width: 350px;
            z-index: 100;
        }
        #tile-layer-panel.visible {
            display: block;
        }
        .theme-day #tile-layer-panel {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #tile-layer-panel {
            background: rgba(0, 20, 40, 0.92);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #tile-layer-panel {
            background: rgba(0, 20, 0, 0.95);
            border: 1px solid #00ff00;
        }
        #tile-layer-panel h4 {
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        .theme-day #tile-layer-panel h4 { color: #0066cc; }
        .theme-night #tile-layer-panel h4 { color: #00d4ff; }
        .theme-retro #tile-layer-panel h4 { color: #00ff00; }
        #custom-tile-url {
            width: 100%;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85em;
            margin-bottom: 10px;
        }
        .theme-day #custom-tile-url {
            background: #fff;
            border: 1px solid #ccc;
            color: #333;
        }
        .theme-night #custom-tile-url {
            background: #1a3a5a;
            border: 1px solid #0066cc;
            color: #fff;
        }
        .theme-retro #custom-tile-url {
            background: #001a00;
            border: 1px solid #00ff00;
            color: #00ff00;
        }
        .tile-url-hint {
            font-size: 0.75em;
            opacity: 0.7;
            margin-bottom: 10px;
        }
        .tile-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tile-preset-btn {
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.75em;
            cursor: pointer;
        }

        /* Export Panel */
        #export-panel {
            position: absolute;
            bottom: 100px;
            right: 20px;
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: none;
            min-width: 200px;
            z-index: 100;
        }
        #export-panel.visible {
            display: block;
        }
        .theme-day #export-panel {
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 100, 200, 0.3);
        }
        .theme-night #export-panel {
            background: rgba(0, 20, 40, 0.92);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        .theme-retro #export-panel {
            background: rgba(0, 20, 0, 0.95);
            border: 1px solid #00ff00;
        }
        #export-panel h4 {
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        .theme-day #export-panel h4 { color: #0066cc; }
        .theme-night #export-panel h4 { color: #00d4ff; }
        .theme-retro #export-panel h4 { color: #00ff00; }
        .export-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .export-btn {
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Alert notifications */
        #alert-container {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 280px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .alert-notification {
            padding: 12px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            animation: slideIn 0.3s ease;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .alert-notification:hover {
            transform: scale(1.02);
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .alert-emergency {
            background: rgba(255, 50, 50, 0.9);
            border: 2px solid #ff0000;
            color: #fff;
        }
        .alert-military {
            background: rgba(100, 100, 150, 0.9);
            border: 2px solid #8888ff;
            color: #fff;
        }
        .alert-lowalt {
            background: rgba(255, 150, 50, 0.9);
            border: 2px solid #ffaa00;
            color: #fff;
        }
        .theme-retro .alert-notification {
            border-color: #00ff00;
            background: rgba(0, 40, 0, 0.95);
            color: #00ff00;
        }
        .alert-icon {
            font-size: 1.2em;
            margin-right: 5px;
        }
        .alert-title {
            font-weight: bold;
            font-size: 0.9em;
        }
        .alert-details {
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: 4px;
        }

        /* Flight path prediction line */
        .prediction-line {
            stroke-dasharray: 5, 5;
        }

        /* Airport markers */
        .airport-marker-label {
            pointer-events: none;
        }

        /* Mobile collapsible controls */
        #mobile-toggle {
            display: none;
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            z-index: 200;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .theme-day #mobile-toggle {
            background: linear-gradient(135deg, #0088ff, #0066cc);
            color: #fff;
        }
        .theme-night #mobile-toggle {
            background: linear-gradient(135deg, #0066cc, #003399);
            color: #fff;
        }
        .theme-retro #mobile-toggle {
            background: rgba(0, 40, 0, 0.95);
            color: #00ff00;
            border: 2px solid #00ff00;
        }

        @media (max-width: 768px) {
            #mobile-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            #controls {
                transform: translateX(-50%) translateY(100%);
                opacity: 0;
                pointer-events: none;
                transition: transform 0.3s ease, opacity 0.3s ease;
            }
            #controls.mobile-visible {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
                pointer-events: auto;
            }
            #search-panel {
                top: auto;
                bottom: 90px;
                left: 10px;
                right: 10px;
                transform: none;
                max-width: 100%;
            }
            #search-panel.collapsed {
                bottom: 90px;
                width: auto;
                left: auto;
                right: 10px;
            }
            #info-panel {
                max-height: 40vh;
                overflow-y: auto;
            }
            #selected-plane {
                max-height: 40vh;
                overflow-y: auto;
            }
            #alert-container {
                top: auto;
                bottom: 150px;
                right: 10px;
                left: 10px;
                width: auto;
            }
        }

        @media (max-width: 480px) {
            #info-panel {
                max-width: 45vw;
                padding: 10px;
            }
            #info-panel h2 {
                font-size: 1em;
            }
            #selected-plane {
                max-width: 50vw;
                padding: 10px;
            }
            #search-panel {
                padding: 8px 12px;
            }
            #search-input {
                width: 100%;
            }
            .search-filters {
                width: 100%;
            }
            .filter-group {
                width: 100%;
            }
            .filter-group select {
                flex: 1;
            }
        }

        /* Improved labels styling */
        .label-enhanced {
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="theme-retro">
    <div id="container"></div>

    <!-- Search & Filter Panel -->
    <div id="search-panel">
        <button id="search-toggle" onclick="toggleSearchPanel()" title="Toggle filters">üîç</button>
        <input type="text" id="search-input" placeholder="Search callsign..." oninput="filterAircraft()">
        <div class="search-filters">
            <div class="filter-group">
                <label>Alt:</label>
                <select id="filter-altitude" onchange="filterAircraft()">
                    <option value="">All</option>
                    <option value="0-5000">0-5k ft</option>
                    <option value="5000-15000">5-15k ft</option>
                    <option value="15000-30000">15-30k ft</option>
                    <option value="30000-45000">30-45k ft</option>
                    <option value="45000+">45k+ ft</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Speed:</label>
                <select id="filter-speed" onchange="filterAircraft()">
                    <option value="">All</option>
                    <option value="0-150">0-150 kts</option>
                    <option value="150-300">150-300 kts</option>
                    <option value="300-500">300-500 kts</option>
                    <option value="500+">500+ kts</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Type:</label>
                <select id="filter-type" onchange="filterAircraft()">
                    <option value="">All</option>
                    <option value="jet">Jets</option>
                    <option value="widebody">Wide-body</option>
                    <option value="regional">Regional</option>
                    <option value="small">Small/GA</option>
                    <option value="helicopter">Helicopters</option>
                    <option value="military">Military</option>
                </select>
            </div>
            <button id="search-clear" onclick="clearFilters()">Clear</button>
        </div>
        <span id="search-results-count">0 shown</span>
    </div>

    <!-- Alert Container -->
    <div id="alert-container"></div>

    <!-- Export Panel -->
    <div id="export-panel">
        <h4>üì§ Export Data</h4>
        <div class="export-options">
            <button class="export-btn" onclick="exportToCSV()">üìÑ Export CSV</button>
            <button class="export-btn" onclick="exportToJSON()">üìã Export JSON</button>
            <button class="export-btn" onclick="exportFlightHistory()">üìö Export History</button>
        </div>
    </div>

    <!-- Custom Tile Layer Panel -->
    <div id="tile-layer-panel">
        <h4>üó∫Ô∏è Custom Map Tiles</h4>
        <input type="text" id="custom-tile-url" placeholder="https://example.com/{z}/{x}/{y}.png">
        <div class="tile-url-hint">Format: {z}=zoom, {x}=x tile, {y}=y tile</div>
        <div class="tile-presets">
            <button class="tile-preset-btn" onclick="setTilePreset('osm')">OSM</button>
            <button class="tile-preset-btn" onclick="setTilePreset('carto-dark')">Carto Dark</button>
            <button class="tile-preset-btn" onclick="setTilePreset('carto-light')">Carto Light</button>
            <button class="tile-preset-btn" onclick="setTilePreset('stamen-terrain')">Terrain</button>
            <button class="tile-preset-btn" onclick="setTilePreset('esri-sat')">Satellite</button>
        </div>
        <button onclick="applyCustomTiles()" style="width:100%;">Apply Custom Tiles</button>
    </div>

    <div id="info-panel">
        <h2>üõ©Ô∏è Live Flight Tracker</h2>
        <div class="stat">
            <span class="stat-label">Aircraft Tracked:</span>
            <span class="stat-value" id="plane-count">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">Last Update:</span>
            <span class="stat-value" id="last-update">--:--:--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Center:</span>
            <span class="stat-value" id="center-coords">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Map Zoom:</span>
            <span class="stat-value" id="map-zoom">9</span>
        </div>
        <div class="stat" style="font-size: 0.8em; opacity: 0.7; margin-top: 10px;">
            <span class="stat-label">Data:</span>
            <span class="stat-value" id="data-info">Web ADS-B</span>
        </div>
        <!-- Expandable Stats Section -->
        <div id="stats-section">
            <div class="stats-grid">
                <div class="stats-item">
                    <span class="value" id="stats-total-tracked">0</span>
                    <span class="label">Unique (24h)</span>
                </div>
                <div class="stats-item">
                    <span class="value" id="stats-max-concurrent">0</span>
                    <span class="label">Max Concurrent</span>
                </div>
                <div class="stats-item">
                    <span class="value" id="stats-avg-altitude">0</span>
                    <span class="label">Avg Altitude</span>
                </div>
                <div class="stats-item">
                    <span class="value" id="stats-data-quality">--%</span>
                    <span class="label">Data Quality</span>
                </div>
            </div>
            <h4 style="margin-bottom: 8px; font-size: 0.8em; opacity: 0.8;">Coverage Heatmap</h4>
            <canvas class="coverage-map" id="coverage-canvas"></canvas>
            <h4 style="margin-bottom: 8px; font-size: 0.8em; opacity: 0.8;">Altitude Distribution</h4>
            <div class="altitude-distribution" id="altitude-distribution">
                <div class="altitude-bar">
                    <span class="label">&lt;5k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-0" style="width: 0%; background: #00ff00;"></div></div>
                    <span class="count" id="alt-count-0">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">5-15k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-1" style="width: 0%; background: #88ff00;"></div></div>
                    <span class="count" id="alt-count-1">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">15-30k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-2" style="width: 0%; background: #ffff00;"></div></div>
                    <span class="count" id="alt-count-2">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">30-40k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-3" style="width: 0%; background: #ff8800;"></div></div>
                    <span class="count" id="alt-count-3">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">&gt;40k ft</span>
                    <div class="bar"><div class="fill" id="alt-bar-4" style="width: 0%; background: #ff0088;"></div></div>
                    <span class="count" id="alt-count-4">0</span>
                </div>
            </div>
            <h4 style="margin: 12px 0 8px 0; font-size: 0.8em; opacity: 0.8;">Top Airlines</h4>
            <div id="top-aircraft-types" style="font-size: 0.8em;"></div>
            <h4 style="margin: 12px 0 8px 0; font-size: 0.8em; opacity: 0.8;">Aircraft Types</h4>
            <div id="aircraft-type-chart" style="font-size: 0.8em;"></div>
            <h4 style="margin: 12px 0 8px 0; font-size: 0.8em; opacity: 0.8;">Speed Distribution</h4>
            <div class="speed-distribution" id="speed-distribution">
                <div class="altitude-bar">
                    <span class="label">&lt;150 kts</span>
                    <div class="bar"><div class="fill" id="spd-bar-0" style="width: 0%; background: #00ffff;"></div></div>
                    <span class="count" id="spd-count-0">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">150-300</span>
                    <div class="bar"><div class="fill" id="spd-bar-1" style="width: 0%; background: #00ff88;"></div></div>
                    <span class="count" id="spd-count-1">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">300-450</span>
                    <div class="bar"><div class="fill" id="spd-bar-2" style="width: 0%; background: #ffff00;"></div></div>
                    <span class="count" id="spd-count-2">0</span>
                </div>
                <div class="altitude-bar">
                    <span class="label">&gt;450 kts</span>
                    <div class="bar"><div class="fill" id="spd-bar-3" style="width: 0%; background: #ff8800;"></div></div>
                    <span class="count" id="spd-count-3">0</span>
                </div>
            </div>
        </div>
    </div>

    <div id="selected-plane">
        <h3>Selected Aircraft</h3>
        <div class="stat">
            <span class="stat-label">Callsign:</span>
            <span class="stat-value" id="sel-callsign">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Altitude:</span>
            <span class="stat-value" id="sel-altitude">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Speed:</span>
            <span class="stat-value" id="sel-speed">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Track:</span>
            <span class="stat-value" id="sel-track">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Vert Rate:</span>
            <span class="stat-value" id="sel-vertrate">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Squawk:</span>
            <span class="stat-value" id="sel-squawk">--</span>
        </div>
        <div class="stat">
            <span class="stat-label">Position:</span>
            <span class="stat-value" id="sel-position">--</span>
        </div>
        <!-- Aircraft Enriched Information -->
        <div id="aircraft-enriched-info">
            <div class="enriched-loading" id="enriched-loading">Loading aircraft info...</div>
            <div id="enriched-data" style="display:none;">
                <div class="enriched-row">
                    <span class="enriched-label">Registration:</span>
                    <span class="enriched-value" id="sel-registration">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Aircraft:</span>
                    <span class="enriched-value" id="sel-aircraft-type">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Operator:</span>
                    <span class="enriched-value" id="sel-operator">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Origin:</span>
                    <span class="enriched-value" id="sel-origin">--</span>
                </div>
                <div class="enriched-row">
                    <span class="enriched-label">Destination:</span>
                    <span class="enriched-value" id="sel-destination">--</span>
                </div>
                <img id="aircraft-photo" alt="Aircraft" />
                <div class="external-links">
                    <a class="external-link" id="link-flightaware" href="#" target="_blank">FlightAware</a>
                    <a class="external-link" id="link-fr24" href="#" target="_blank">FR24</a>
                    <a class="external-link" id="link-adsbx" href="#" target="_blank">ADSB-X</a>
                </div>
            </div>
        </div>
    </div>

    <div id="graphs-panel">
        <h3>ADS-B Statistics <span class="graphs1090-status local" id="graphs-status">Web Data</span></h3>

        <div class="time-period-selector">
            <button class="time-period-btn active" onclick="setGraphsTimePeriod(3600)" data-period="3600">1h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(7200)" data-period="7200">2h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(28800)" data-period="28800">8h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(86400)" data-period="86400">24h</button>
            <button class="time-period-btn" onclick="setGraphsTimePeriod(172800)" data-period="172800">48h</button>
        </div>

        <div class="graph-card" id="card-message-rate">
            <h4>Message Rate</h4>
            <div class="graph-current-value" id="msg-rate-value">-- msg/s</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-msg-rate"></canvas>
            </div>
            <div class="graph-stats">
                <span id="msg-rate-min">Min: --</span>
                <span id="msg-rate-max">Max: --</span>
            </div>
        </div>

        <div class="graph-card" id="card-aircraft">
            <h4>Aircraft Tracked</h4>
            <div class="graph-current-value" id="aircraft-value">--</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-aircraft"></canvas>
            </div>
            <div class="graph-stats">
                <span id="aircraft-min">Min: --</span>
                <span id="aircraft-max">Max: --</span>
            </div>
        </div>

        <div class="graph-card" id="card-signal">
            <h4>Signal Level</h4>
            <div class="graph-current-value" id="signal-value">-- dBFS</div>
            <div class="graph-canvas-container">
                <canvas class="graph-canvas" id="canvas-signal"></canvas>
            </div>
            <div class="graph-stats">
                <span id="signal-min">Min: --</span>
                <span id="signal-max">Max: --</span>
            </div>
        </div>
    </div>

    <div id="controls">
        <div class="control-group">
            <span class="control-label">Location:</span>
            <select id="location-select" onchange="changeLocation(this.value)">
                <option value="new-york">New York</option>
                <option value="london">London</option>
                <option value="los-angeles">Los Angeles</option>
                <option value="tokyo">Tokyo</option>
                <option value="paris">Paris</option>
                <option value="sydney">Sydney</option>
                <option value="dubai">Dubai</option>
                <option value="singapore">Singapore</option>
                <option value="chicago">Chicago</option>
                <option value="frankfurt">Frankfurt</option>
                <option value="atlanta">Atlanta</option>
                <option value="dallas">Dallas/Fort Worth</option>
                <option value="denver">Denver</option>
                <option value="seattle">Seattle</option>
                <option value="miami">Miami</option>
                <option value="amsterdam">Amsterdam</option>
                <option value="hong-kong">Hong Kong</option>
                <option value="beijing">Beijing</option>
                <option value="custom">Custom...</option>
            </select>
            <button onclick="useMyLocation()" title="Use my location">üìç</button>
        </div>

        <div class="control-group">
            <span class="control-label">Radius:</span>
            <input type="range" id="radius-slider" min="50" max="500" value="250" step="25" oninput="changeRadius(this.value)">
            <span id="radius-value">250 nm</span>
        </div>

        <div class="control-group">
            <span class="control-label">Source:</span>
            <select id="source-select" onchange="changeDataSource(this.value)">
                <option value="adsb-lol">ADSB.lol</option>
                <option value="opensky">OpenSky</option>
            </select>
            <span class="data-status connected" id="data-source-status">ADSB.lol</span>
        </div>

        <div class="control-group">
            <span class="control-label">Theme:</span>
            <select id="theme-select" onchange="changeTheme(this.value)">
                <option value="day">Day</option>
                <option value="night">Night</option>
                <option value="retro" selected>Retro 80s</option>
            </select>
        </div>

        <div class="control-group">
            <span class="control-label">Units:</span>
            <select id="units-select" onchange="changeUnits(this.value)">
                <option value="imperial">Imperial (ft/kts)</option>
                <option value="metric">Metric (m/km/h)</option>
            </select>
        </div>

        <div class="control-group">
            <span class="control-label">Map:</span>
            <button onclick="mapZoomIn()">+</button>
            <button onclick="mapZoomOut()">-</button>
            <button onclick="panMap('up')">‚Üë</button>
            <button onclick="panMap('down')">‚Üì</button>
            <button onclick="panMap('left')">‚Üê</button>
            <button onclick="panMap('right')">‚Üí</button>
        </div>

        <div class="control-group">
            <span class="control-label">Camera:</span>
            <button onclick="cameraZoomIn()">Zoom+</button>
            <button onclick="cameraZoomOut()">Zoom-</button>
            <button onmousedown="startRotate('left')" onmouseup="stopRotate()" onmouseleave="stopRotate()">‚óÑ</button>
            <button onmousedown="startRotate('right')" onmouseup="stopRotate()" onmouseleave="stopRotate()">‚ñ∫</button>
        </div>

        <div class="control-group">
            <span class="control-label">View:</span>
            <button onclick="enableFollow('standard')" id="btn-follow">Follow</button>
            <button onclick="enableFollow('chase')" id="btn-chase">Chase</button>
            <button onclick="enableFollow('cockpit')" id="btn-cockpit">Cockpit</button>
            <button onclick="enableFollow('cinematic')" id="btn-cinematic">Orbit</button>
            <button onclick="disableFollow()" id="btn-unfollow">Unfollow</button>
        </div>

        <div class="control-group">
            <button onclick="resetCamera()">Reset</button>
            <button onclick="toggleAutoRotate()" id="btn-rotate">Auto Rotate</button>
            <button onclick="toggleLabels()" id="btn-labels">Labels</button>
            <button onclick="toggleGraphs()" id="btn-graphs">Graphs</button>
            <button onclick="toggleStats()" id="btn-stats">Stats</button>
        </div>

        <div class="control-group trail-control">
            <button onclick="toggleTrails()" id="btn-trails">Trails</button>
            <span class="control-label">Length:</span>
            <input type="range" id="trail-length-slider" min="50" max="500" value="200" oninput="setTrailLength(this.value)">
            <span id="trail-length-value">200</span>
            <span class="control-label">Width:</span>
            <input type="range" id="trail-thickness-slider" min="1" max="5" value="2" oninput="setTrailThickness(this.value)">
            <button onclick="clearAllTrails()" title="Clear all trails">Clear</button>
        </div>

        <div class="control-group altitude-control">
            <span class="control-label">Alt:</span>
            <input type="range" id="altitude-slider" min="100" max="30000" value="100" step="100">
            <span id="altitude-value">1x</span>
        </div>

        <div class="control-group">
            <button onclick="toggleKeyboardHelp()" id="btn-help" title="Keyboard Shortcuts">?</button>
            <button onclick="toggleExportPanel()" id="btn-export" title="Export Data">üì§</button>
            <button onclick="toggleTilePanel()" id="btn-tiles" title="Custom Map Tiles">üó∫Ô∏è</button>
            <button onclick="toggleAirports()" id="btn-airports" title="Toggle Airport Markers">‚úàÔ∏è</button>
            <button onclick="toggleAlerts()" id="btn-alerts" title="Toggle Alerts" class="active">üîî</button>
            <button onclick="togglePrediction()" id="btn-prediction" title="Toggle Flight Prediction">üìç</button>
        </div>
    </div>

    <!-- Mobile toggle button -->
    <button id="mobile-toggle" onclick="toggleMobileControls()">‚öôÔ∏è</button>

    <!-- Keyboard Help Overlay -->
    <div id="keyboard-help">
        <div id="keyboard-help-content">
            <h2>Keyboard Shortcuts</h2>
            <div class="shortcut-group">
                <h3>Navigation</h3>
                <div class="shortcut-row"><span class="shortcut-key">‚Üë‚Üì‚Üê‚Üí</span><span class="shortcut-desc">Pan map</span></div>
                <div class="shortcut-row"><span class="shortcut-key">+ / =</span><span class="shortcut-desc">Zoom camera in</span></div>
                <div class="shortcut-row"><span class="shortcut-key">- / _</span><span class="shortcut-desc">Zoom camera out</span></div>
                <div class="shortcut-row"><span class="shortcut-key">[ / ]</span><span class="shortcut-desc">Rotate camera left/right</span></div>
                <div class="shortcut-row"><span class="shortcut-key">R</span><span class="shortcut-desc">Reset camera view</span></div>
                <div class="shortcut-row"><span class="shortcut-key">M + / M -</span><span class="shortcut-desc">Map zoom in/out</span></div>
            </div>
            <div class="shortcut-group">
                <h3>Display</h3>
                <div class="shortcut-row"><span class="shortcut-key">L</span><span class="shortcut-desc">Toggle labels</span></div>
                <div class="shortcut-row"><span class="shortcut-key">G</span><span class="shortcut-desc">Toggle graphs</span></div>
                <div class="shortcut-row"><span class="shortcut-key">A</span><span class="shortcut-desc">Toggle auto-rotate</span></div>
                <div class="shortcut-row"><span class="shortcut-key">T</span><span class="shortcut-desc">Toggle trails</span></div>
                <div class="shortcut-row"><span class="shortcut-key">C</span><span class="shortcut-desc">Clear all trails</span></div>
                <div class="shortcut-row"><span class="shortcut-key">S</span><span class="shortcut-desc">Toggle stats panel</span></div>
                <div class="shortcut-row"><span class="shortcut-key">1 / 2 / 3</span><span class="shortcut-desc">Switch theme (Day/Night/Retro)</span></div>
            </div>
            <div class="shortcut-group">
                <h3>Selection</h3>
                <div class="shortcut-row"><span class="shortcut-key">Tab</span><span class="shortcut-desc">Select next aircraft</span></div>
                <div class="shortcut-row"><span class="shortcut-key">Shift+Tab</span><span class="shortcut-desc">Select previous aircraft</span></div>
                <div class="shortcut-row"><span class="shortcut-key">Escape</span><span class="shortcut-desc">Deselect / Close panels</span></div>
                <div class="shortcut-row"><span class="shortcut-key">F</span><span class="shortcut-desc">Follow selected aircraft</span></div>
            </div>
            <div class="shortcut-group">
                <h3>Features</h3>
                <div class="shortcut-row"><span class="shortcut-key">/</span><span class="shortcut-desc">Search aircraft</span></div>
                <div class="shortcut-row"><span class="shortcut-key">E</span><span class="shortcut-desc">Export panel</span></div>
                <div class="shortcut-row"><span class="shortcut-key">P</span><span class="shortcut-desc">Toggle airports</span></div>
                <div class="shortcut-row"><span class="shortcut-key">N</span><span class="shortcut-desc">Toggle prediction lines</span></div>
            </div>
            <p class="close-hint">Press <strong>?</strong> or <strong>Escape</strong> to close</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration
        // ADS-B Data Sources (web-based)
        const ADSB_SOURCES = {
            'adsb-lol': {
                name: 'ADSB.lol',
                // Get aircraft within a geographic bounding box
                getUrl: (lat, lon, radius) => {
                    // radius in nm, API uses lat/lon bounds
                    const latDelta = radius / 60; // 1 degree = 60nm approx
                    const lonDelta = radius / (60 * Math.cos(lat * Math.PI / 180));
                    return `https://api.adsb.lol/v2/lat/${lat}/lon/${lon}/dist/${radius}`;
                },
                parseResponse: (data) => {
                    if (!data.ac) return [];
                    return data.ac.map(ac => ({
                        hex: ac.hex || ac.icao,
                        flight: ac.flight || ac.callsign || '',
                        lat: ac.lat,
                        lon: ac.lon,
                        altitude: ac.alt_baro || ac.alt_geom || ac.altitude || 0,
                        alt_baro: ac.alt_baro,
                        alt_geom: ac.alt_geom,
                        track: ac.track || ac.mag_heading || ac.true_heading || 0,
                        gs: ac.gs || ac.tas || ac.ias || 0,
                        baro_rate: ac.baro_rate || ac.geom_rate || 0,
                        squawk: ac.squawk || '',
                        category: ac.category || ac.t || '',
                        type: ac.t || ac.type || '',
                        registration: ac.r || ac.registration || '',
                        seen: ac.seen || 0,
                        messages: ac.messages || 0
                    }));
                }
            },
            'opensky': {
                name: 'OpenSky Network',
                getUrl: (lat, lon, radius) => {
                    const latDelta = radius / 60;
                    const lonDelta = radius / (60 * Math.cos(lat * Math.PI / 180));
                    return `https://opensky-network.org/api/states/all?lamin=${lat-latDelta}&lomin=${lon-lonDelta}&lamax=${lat+latDelta}&lomax=${lon+lonDelta}`;
                },
                parseResponse: (data) => {
                    if (!data.states) return [];
                    return data.states.map(s => ({
                        hex: s[0],
                        flight: (s[1] || '').trim(),
                        lat: s[6],
                        lon: s[5],
                        altitude: (s[13] || s[7] || 0) * 3.28084, // meters to feet
                        alt_baro: s[7] ? s[7] * 3.28084 : null,
                        alt_geom: s[13] ? s[13] * 3.28084 : null,
                        track: s[10] || 0,
                        gs: (s[9] || 0) * 1.94384, // m/s to knots
                        baro_rate: (s[11] || 0) * 196.85, // m/s to ft/min
                        squawk: s[14] || '',
                        category: '',
                        type: '',
                        registration: '',
                        seen: 0,
                        messages: 0
                    })).filter(a => a.lat && a.lon);
                }
            },
            'adsbexchange': {
                name: 'ADS-B Exchange',
                getUrl: (lat, lon, radius) => {
                    return `https://adsbexchange.com/api/aircraft/v2/lat/${lat}/lon/${lon}/dist/${radius}/`;
                },
                parseResponse: (data) => {
                    if (!data.ac) return [];
                    return data.ac.map(ac => ({
                        hex: ac.hex || ac.icao,
                        flight: ac.flight || ac.callsign || '',
                        lat: ac.lat,
                        lon: ac.lon,
                        altitude: ac.alt_baro || ac.alt_geom || 0,
                        alt_baro: ac.alt_baro,
                        alt_geom: ac.alt_geom,
                        track: ac.track || 0,
                        gs: ac.gs || 0,
                        baro_rate: ac.baro_rate || 0,
                        squawk: ac.squawk || '',
                        category: ac.category || '',
                        type: ac.t || '',
                        registration: ac.r || '',
                        seen: ac.seen || 0,
                        messages: ac.messages || 0
                    }));
                }
            }
        };

        // Default data source and location settings
        let currentDataSource = 'adsb-lol';
        let viewLatitude = 40.7128;  // Default: New York City
        let viewLongitude = -74.0060;
        let viewRadius = 250; // nautical miles
        let dataSourceWorking = true;
        let lastFetchError = null;

        // Predefined locations for easy selection
        const PRESET_LOCATIONS = {
            'new-york': { name: 'New York', lat: 40.7128, lon: -74.0060 },
            'london': { name: 'London', lat: 51.5074, lon: -0.1278 },
            'los-angeles': { name: 'Los Angeles', lat: 34.0522, lon: -118.2437 },
            'tokyo': { name: 'Tokyo', lat: 35.6762, lon: 139.6503 },
            'paris': { name: 'Paris', lat: 48.8566, lon: 2.3522 },
            'sydney': { name: 'Sydney', lat: -33.8688, lon: 151.2093 },
            'dubai': { name: 'Dubai', lat: 25.2048, lon: 55.2708 },
            'singapore': { name: 'Singapore', lat: 1.3521, lon: 103.8198 },
            'chicago': { name: 'Chicago', lat: 41.8781, lon: -87.6298 },
            'frankfurt': { name: 'Frankfurt', lat: 50.1109, lon: 8.6821 },
            'atlanta': { name: 'Atlanta', lat: 33.6407, lon: -84.4277 },
            'dallas': { name: 'Dallas/Fort Worth', lat: 32.8998, lon: -97.0403 },
            'denver': { name: 'Denver', lat: 39.8561, lon: -104.6737 },
            'seattle': { name: 'Seattle', lat: 47.4502, lon: -122.3088 },
            'miami': { name: 'Miami', lat: 25.7959, lon: -80.2870 },
            'amsterdam': { name: 'Amsterdam', lat: 52.3105, lon: 4.7683 },
            'hong-kong': { name: 'Hong Kong', lat: 22.3080, lon: 113.9185 },
            'beijing': { name: 'Beijing', lat: 40.0799, lon: 116.6031 },
            'custom': { name: 'Custom Location', lat: null, lon: null }
        };

        const REFRESH_INTERVAL = 3000; // 3 seconds for web API (respect rate limits)
        const MAP_GROUND_SIZE = 800;
        const TILES_PER_SIDE = 10;
        // Altitude scale: 1x-300x range, reduced by 30x (new 300x = old 10x effect)
        const BASE_ALT_SCALE = 0.000000333;

        // Cookie helper functions
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(JSON.stringify(value)) + '; expires=' + expires + '; path=/; SameSite=Lax';
        }

        function getCookie(name) {
            const value = document.cookie.split('; ').find(row => row.startsWith(name + '='));
            if (value) {
                try {
                    return JSON.parse(decodeURIComponent(value.split('=')[1]));
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        function saveSettings() {
            const settings = {
                theme: currentTheme,
                units: currentUnits,
                showLabels: showLabels,
                trailEnabled: trailEnabled,
                trailMaxLength: trailMaxLength,
                trailThickness: trailThickness,
                trailColorMode: trailColorMode,
                autoRotate: autoRotate,
                showGraphs: showGraphs,
                graphsTimePeriod: graphsTimePeriod,
                altitudeScaleValue: Math.round(altitudeScale / BASE_ALT_SCALE),
                // New web data settings
                dataSource: currentDataSource,
                viewLat: viewLatitude,
                viewLon: viewLongitude,
                viewRadius: viewRadius
            };
            setCookie('flightTrackerSettings', settings);
        }

        function loadSettings() {
            const settings = getCookie('flightTrackerSettings');
            if (settings) {
                if (settings.theme) currentTheme = settings.theme;
                if (settings.units) currentUnits = settings.units;
                if (settings.showLabels !== undefined) showLabels = settings.showLabels;
                if (settings.trailEnabled !== undefined) trailEnabled = settings.trailEnabled;
                if (settings.trailMaxLength !== undefined) trailMaxLength = settings.trailMaxLength;
                if (settings.trailThickness !== undefined) trailThickness = settings.trailThickness;
                if (settings.trailColorMode !== undefined) trailColorMode = settings.trailColorMode;
                if (settings.autoRotate !== undefined) autoRotate = settings.autoRotate;
                if (settings.showGraphs !== undefined) showGraphs = settings.showGraphs;
                if (settings.graphsTimePeriod !== undefined) graphsTimePeriod = settings.graphsTimePeriod;
                if (settings.altitudeScaleValue !== undefined) {
                    // Internal scale: 100-30000 (displayed as 1x-300x)
                    let newScale = settings.altitudeScaleValue;
                    // Clamp to valid range
                    newScale = Math.max(100, Math.min(30000, newScale));
                    altitudeScale = newScale * BASE_ALT_SCALE;
                }
                // Load web data settings
                if (settings.dataSource) currentDataSource = settings.dataSource;
                if (settings.viewLat !== undefined) viewLatitude = settings.viewLat;
                if (settings.viewLon !== undefined) viewLongitude = settings.viewLon;
                if (settings.viewRadius !== undefined) viewRadius = settings.viewRadius;
            }
        }

        // State
        let scene, camera, renderer;
        let airplanes = new Map();
        let labels = [];
        let showLabels = true;
        let autoRotate = false;
        let selectedPlane = null;
        let centerLat = 0, centerLon = 0;
        let centerInitialized = false;

        // Trail settings (airloom-style)
        let trailEnabled = true;
        let trailMaxLength = 200; // Max trail points
        let trailThickness = 2; // Line thickness (1-5)
        let trailColorMode = 'altitude'; // 'altitude' or 'speed'

        // Interpolation state
        const INTERPOLATION_DELAY = 2000; // 2 second delay
        const INTERPOLATION_FPS = 30;
        let aircraftDataBuffer = new Map(); // hex -> array of {timestamp, data}
        let lastInterpolationTime = 0;

        // Performance: Cached/reusable objects to avoid GC pressure
        const _raycaster = new THREE.Raycaster();
        const _mouseVec = new THREE.Vector2();
        const _tempPos = { x: 0, z: 0 };
        const _seenHexes = new Set();
        let _airplanesArray = []; // Cached array of airplane entries for iteration
        let _airplanesArrayDirty = true; // Flag to rebuild array when airplanes change

        // Performance: Label canvas pool for reuse
        const _labelCanvasPool = [];
        const _labelTexturePool = [];
        const MAX_LABEL_POOL_SIZE = 100;

        // Performance: Shared geometry instances (created once, reused for all aircraft)
        let _sharedGeometries = null;

        // Glow effect texture and material (sprite-based glow like airloom)
        let _glowTexture = null;
        let _glowMaterialRetro = null;
        let _glowMaterialDay = null;

        // Performance: Material pools
        const _materialPool = {
            wireframe: [],
            phong: [],
            basic: []
        };
        const MAX_MATERIAL_POOL_SIZE = 50;

        // Performance: Trail geometry pool
        const _trailGeometryPool = [];
        const MAX_TRAIL_POOL_SIZE = 50;

        // Performance: Distance-based LOD thresholds
        const LOD_DISTANCE_FAR = 400; // Distance for simplified rendering
        const LOD_DISTANCE_CULL = 700; // Distance for label culling

        // Performance: Batch update flags
        let _trailUpdateQueue = [];
        let _lastBatchTrailUpdate = 0;
        const BATCH_TRAIL_INTERVAL = 50; // Batch trail updates every 50ms

        // Performance: Throttle flags
        let _lastTrailFilterTime = 0;
        const TRAIL_FILTER_INTERVAL = 500; // Filter trails every 500ms max

        // Performance: Tab visibility for power saving
        let _isTabVisible = true;

        // Performance: Render on demand flag
        let _needsRender = true;
        let _renderThrottleTime = 0;
        const RENDER_THROTTLE_MS = 16; // Cap at ~60fps

        // Map state
        let currentZoom = 9;
        const MIN_ZOOM = 6;
        const MAX_ZOOM = 12;
        let mapTiles = [];
        let tileCache = new Map();
        const MAX_TILE_CACHE_SIZE = 300; // Limit texture cache memory (increased for larger map)

        // Smooth map transition state
        let mapTransition = {
            active: false,
            startLat: 0,
            startLon: 0,
            targetLat: 0,
            targetLon: 0,
            startZoom: 9,
            targetZoom: 9,
            startTime: 0,
            duration: 300, // ms
            easing: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2 // easeInOutCubic
        };

        // Tile preloading state
        let preloadedTiles = new Map(); // cache key -> {texture, loading}
        let preloadQueue = [];
        let preloadInProgress = 0;
        const MAX_CONCURRENT_PRELOADS = 4;

        // Altitude scale
        let altitudeScale = 30 * BASE_ALT_SCALE;

        // Units: 'imperial' or 'metric'
        let currentUnits = 'imperial';

        // Theme: 'day', 'night', 'retro'
        let currentTheme = 'retro';

        // Graphs panel state
        let showGraphs = false;
        let statsDb = null;
        let graphsTimePeriod = 3600; // Default 1 hour in seconds
        let statsHistory = {
            messageRate: [],
            aircraftCount: [],
            signalLevel: []
        };
        const STATS_HISTORY_MAX = 172800; // 48 hours at 1s intervals

        // Camera controls
        let cameraAngle = 0;
        let cameraHeight = 80;
        let cameraDistance = 150;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Follow mode
        let followSelectedPlane = false;

        // Stats panel state (integrated in info-panel)
        let showStats = false;
        let uniqueAircraftSeen = new Set();
        let maxConcurrentAircraft = 0;
        let coverageHeatmap = new Array(20 * 20).fill(0); // 20x20 grid
        let aircraftTypeStats = new Map();

        // Aircraft information cache
        let aircraftInfoCache = new Map();
        let enrichmentApiAvailable = null; // null = unknown, true/false after check

        // Touch gesture state
        let touchStartDistance = 0;
        let touchStartAngle = 0;
        let lastTouchCenter = { x: 0, y: 0 };
        let isTwoFingerGesture = false;

        // ===========================================
        // WEB ADS-B DATA & LOCAL STATS
        // ===========================================

        // Initialize IndexedDB for stats storage
        function initStatsDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('FlightTrackerStats', 2);

                request.onerror = () => {
                    console.warn('IndexedDB not available, using memory only');
                    resolve(null);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Create object stores for each metric
                    if (!db.objectStoreNames.contains('messageRate')) {
                        const msgStore = db.createObjectStore('messageRate', { keyPath: 'timestamp' });
                        msgStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    if (!db.objectStoreNames.contains('aircraft')) {
                        const acStore = db.createObjectStore('aircraft', { keyPath: 'timestamp' });
                        acStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    if (!db.objectStoreNames.contains('signal')) {
                        const sigStore = db.createObjectStore('signal', { keyPath: 'timestamp' });
                        sigStore.createIndex('timestamp', 'timestamp', { unique: true });
                    }
                    // Trail history store - keyed by aircraft hex
                    if (!db.objectStoreNames.contains('trails')) {
                        const trailStore = db.createObjectStore('trails', { keyPath: 'hex' });
                        trailStore.createIndex('lastSeen', 'lastSeen', { unique: false });
                    }
                };

                request.onsuccess = (event) => {
                    statsDb = event.target.result;
                    loadStatsFromDb();
                    resolve(statsDb);
                };
            });
        }

        // Load historical stats from IndexedDB
        function loadStatsFromDb() {
            if (!statsDb) return;

            const now = Date.now();
            const cutoff = now - (STATS_HISTORY_MAX * 1000);

            ['messageRate', 'aircraft', 'signal'].forEach(storeName => {
                const transaction = statsDb.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.openCursor();

                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (cursor.value.timestamp >= cutoff) {
                            if (storeName === 'messageRate') {
                                statsHistory.messageRate.push(cursor.value);
                            } else if (storeName === 'aircraft') {
                                statsHistory.aircraftCount.push({ timestamp: cursor.value.timestamp, value: cursor.value.count || cursor.value.tracked || 0 });
                            } else if (storeName === 'signal') {
                                statsHistory.signalLevel.push(cursor.value);
                            }
                        }
                        cursor.continue();
                    }
                };
            });
        }

        // Save stats to IndexedDB
        function saveStatsToDb(type, data) {
            if (!statsDb) return;

            const transaction = statsDb.transaction([type], 'readwrite');
            const store = transaction.objectStore(type);
            store.put(data);

            // Clean up old entries (keep last 24 hours)
            const cutoff = Date.now() - (24 * 60 * 60 * 1000);
            const deleteRequest = store.openCursor();
            deleteRequest.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    if (cursor.value.timestamp < cutoff) {
                        cursor.delete();
                    }
                    cursor.continue();
                }
            };
        }

        // Save trail history to IndexedDB
        function saveTrailToDb(hex, trailPoints, lat, lon) {
            if (!statsDb || !hex || trailPoints.length < 2) return;

            try {
                const transaction = statsDb.transaction(['trails'], 'readwrite');
                const store = transaction.objectStore('trails');
                store.put({
                    hex: hex,
                    points: trailPoints.slice(-100), // Keep last 100 points
                    lastSeen: Date.now(),
                    lastLat: lat,
                    lastLon: lon
                });
            } catch (e) {
                // Ignore DB errors
            }
        }

        // Load trail history from IndexedDB
        function loadTrailFromDb(hex, callback) {
            if (!statsDb || !hex) {
                callback(null);
                return;
            }

            try {
                const transaction = statsDb.transaction(['trails'], 'readonly');
                const store = transaction.objectStore('trails');
                const request = store.get(hex);

                request.onsuccess = (event) => {
                    const result = event.target.result;
                    // Only use trail if seen within last hour
                    if (result && (Date.now() - result.lastSeen) < 3600000) {
                        callback(result);
                    } else {
                        callback(null);
                    }
                };

                request.onerror = () => callback(null);
            } catch (e) {
                callback(null);
            }
        }

        // Clean up old trails from IndexedDB
        function cleanupOldTrails() {
            if (!statsDb) return;

            try {
                const cutoff = Date.now() - (24 * 60 * 60 * 1000); // 24 hours
                const transaction = statsDb.transaction(['trails'], 'readwrite');
                const store = transaction.objectStore('trails');
                const index = store.index('lastSeen');
                const range = IDBKeyRange.upperBound(cutoff);

                index.openCursor(range).onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
            } catch (e) {
                // Ignore errors
            }
        }

        // Update graphs status to show web data source
        function updateGraphsStatus() {
            const sourceName = ADSB_SOURCES[currentDataSource]?.name || 'Web Data';
            document.getElementById('graphs-status').textContent = sourceName;
            document.getElementById('graphs-status').classList.remove('connected');
            document.getElementById('graphs-status').classList.add('local');
            console.log('Using web ADS-B data from', sourceName);
        }

        // For web-based data, we track metrics from the API responses
        let lastMessageCount = 0;
        let lastMessageTime = Date.now();

        async function fetchStats() {
            const now = Date.now();

            // Get current aircraft count from the UI
            const planeCountEl = document.getElementById('plane-count');
            const aircraftCount = planeCountEl ? (parseInt(planeCountEl.textContent) || 0) : 0;

            // Estimate message rate from aircraft buffer updates
            // Each aircraft position update represents ~1 message
            let totalMessages = 0;
            for (const [hex, buffer] of aircraftDataBuffer.entries()) {
                totalMessages += buffer.length;
            }

            // Calculate message rate (messages per second since last check)
            const timeDelta = (now - lastMessageTime) / 1000;
            const messageDelta = totalMessages - lastMessageCount;
            const messageRate = timeDelta > 0 ? Math.max(0, messageDelta / timeDelta) : 0;

            lastMessageCount = totalMessages;
            lastMessageTime = now;

            // Signal level is not available from web APIs, use placeholder
            const signalLevel = -30; // Placeholder for web data

            // Store in history
            statsHistory.messageRate.push({ timestamp: now, value: messageRate });
            statsHistory.aircraftCount.push({ timestamp: now, value: aircraftCount });
            statsHistory.signalLevel.push({ timestamp: now, value: signalLevel });

            // Trim history
            if (statsHistory.messageRate.length > STATS_HISTORY_MAX) {
                statsHistory.messageRate.shift();
            }
            if (statsHistory.aircraftCount.length > STATS_HISTORY_MAX) {
                statsHistory.aircraftCount.shift();
            }
            if (statsHistory.signalLevel.length > STATS_HISTORY_MAX) {
                statsHistory.signalLevel.shift();
            }

            // Save to IndexedDB
            saveStatsToDb('messageRate', { timestamp: now, value: messageRate });
            saveStatsToDb('aircraft', { timestamp: now, count: aircraftCount });
            saveStatsToDb('signal', { timestamp: now, value: signalLevel });

            // Update display
            updateGraphsDisplay();
        }

        // Filter history data based on selected time period
        function filterHistoryByPeriod(historyArray) {
            const now = Date.now();
            const cutoff = now - (graphsTimePeriod * 1000);
            return historyArray.filter(d => d.timestamp >= cutoff);
        }

        // Update the graphs display
        function updateGraphsDisplay() {
            if (!showGraphs) return;

            const isRetro = currentTheme === 'retro';
            const lineColor = isRetro ? '#00ff00' : (currentTheme === 'night' ? '#00d4ff' : '#0088ff');
            const fillColor = isRetro ? 'rgba(0, 255, 0, 0.2)' : (currentTheme === 'night' ? 'rgba(0, 212, 255, 0.2)' : 'rgba(0, 136, 255, 0.2)');
            const secondLineColor = isRetro ? '#00cc00' : (currentTheme === 'night' ? '#ffaa00' : '#ff8800');

            // Filter data by selected time period
            const filteredMsgRate = filterHistoryByPeriod(statsHistory.messageRate);
            const filteredAircraftCount = filterHistoryByPeriod(statsHistory.aircraftCount);
            const filteredSignal = filterHistoryByPeriod(statsHistory.signalLevel);

            // Message Rate Graph
            if (filteredMsgRate.length > 0) {
                const latest = statsHistory.messageRate.length > 0 ?
                    statsHistory.messageRate[statsHistory.messageRate.length - 1].value : 0;
                document.getElementById('msg-rate-value').textContent = latest.toFixed(1) + ' msg/s';

                const values = filteredMsgRate.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('msg-rate-min').textContent = 'Min: ' + min.toFixed(1);
                document.getElementById('msg-rate-max').textContent = 'Max: ' + max.toFixed(1);

                drawMiniGraph('canvas-msg-rate', values, lineColor, fillColor);
            }

            // Aircraft Count Graph
            if (filteredAircraftCount.length > 0) {
                const latest = statsHistory.aircraftCount.length > 0 ?
                    statsHistory.aircraftCount[statsHistory.aircraftCount.length - 1].value : 0;
                document.getElementById('aircraft-value').textContent = latest;

                const values = filteredAircraftCount.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('aircraft-min').textContent = 'Min: ' + min;
                document.getElementById('aircraft-max').textContent = 'Max: ' + max;

                drawMiniGraph('canvas-aircraft', values, lineColor, fillColor);
            }

            // Signal Level Graph
            if (filteredSignal.length > 0) {
                const latest = statsHistory.signalLevel.length > 0 ?
                    statsHistory.signalLevel[statsHistory.signalLevel.length - 1].value : -50;
                document.getElementById('signal-value').textContent = latest.toFixed(1) + ' dBFS';

                const values = filteredSignal.map(d => d.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                document.getElementById('signal-min').textContent = 'Min: ' + min.toFixed(1) + ' dB';
                document.getElementById('signal-max').textContent = 'Max: ' + max.toFixed(1) + ' dB';

                // Signal is negative, so invert for better visualization
                const normalizedValues = values.map(v => -v);
                drawMiniGraph('canvas-signal', normalizedValues, lineColor, fillColor);
            }
        }

        // Draw a mini graph on canvas
        function drawMiniGraph(canvasId, values, lineColor, fillColor, values2 = null, lineColor2 = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();

            // Set actual canvas size for crisp rendering
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            const padding = 2;

            ctx.clearRect(0, 0, width, height);

            if (values.length < 2) return;

            // Calculate combined min/max if two datasets
            let allValues = values;
            if (values2 && values2.length > 0) {
                allValues = [...values, ...values2];
            }

            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal || 1;

            // Draw helper function
            const drawLine = (data, color, fill) => {
                const stepX = (width - padding * 2) / (data.length - 1);

                ctx.beginPath();
                ctx.moveTo(padding, height - padding);

                for (let i = 0; i < data.length; i++) {
                    const x = padding + i * stepX;
                    const normalizedY = (data[i] - minVal) / range;
                    const y = height - padding - normalizedY * (height - padding * 2);

                    if (i === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                // Complete the fill path
                ctx.lineTo(width - padding, height - padding);
                ctx.closePath();

                ctx.fillStyle = fill;
                ctx.fill();

                // Draw the line on top
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = padding + i * stepX;
                    const normalizedY = (data[i] - minVal) / range;
                    const y = height - padding - normalizedY * (height - padding * 2);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            };

            // Draw primary data
            drawLine(values, lineColor, fillColor);

            // Draw secondary data if provided
            if (values2 && values2.length > 0 && lineColor2) {
                drawLine(values2, lineColor2, 'transparent');
            }
        }

        // Initialize graphs system
        async function initGraphsSystem() {
            await initStatsDatabase();
            updateGraphsStatus();

            // Clean up old trails
            cleanupOldTrails();

            // Start fetching stats
            fetchStats();
            setInterval(fetchStats, 1000);

            // Clean up old trails periodically (every hour)
            setInterval(cleanupOldTrails, 3600000);
        }

        // Expose functions globally for onclick handlers
        window.setGraphsTimePeriod = function(seconds) {
            graphsTimePeriod = seconds;

            // Update button states
            document.querySelectorAll('.time-period-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.period) === seconds);
            });

            // Refresh display
            updateGraphsDisplay();
            saveSettings();
        };

        window.toggleGraphs = function() {
            showGraphs = !showGraphs;
            const panel = document.getElementById('graphs-panel');
            const btn = document.getElementById('btn-graphs');

            if (showGraphs) {
                panel.classList.add('visible');
                btn.classList.add('active');
                updateGraphsDisplay();
            } else {
                panel.classList.remove('visible');
                btn.classList.remove('active');
            }

            saveSettings();
        };

        // Trail control functions (airloom-style)
        window.toggleTrails = function() {
            trailEnabled = !trailEnabled;
            document.getElementById('btn-trails').classList.toggle('active', trailEnabled);

            // Update all existing plane trails visibility
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.trail) {
                    plane.userData.trail.visible = trailEnabled;
                }
            }
            saveSettings();
            _needsRender = true;
        };

        window.setTrailLength = function(length) {
            trailMaxLength = parseInt(length) || 200;
            document.getElementById('trail-length-value').textContent = trailMaxLength;

            // Trim existing trails if needed
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.trailPoints && plane.userData.trailPoints.length > trailMaxLength) {
                    plane.userData.trailPoints = plane.userData.trailPoints.slice(-trailMaxLength);
                    updateTrail(plane);
                }
            }
            saveSettings();
        };

        window.setTrailThickness = function(thickness) {
            trailThickness = parseInt(thickness) || 2;

            // Update all trail materials
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.trailMaterial) {
                    plane.userData.trailMaterial.linewidth = trailThickness;
                    plane.userData.trailMaterial.needsUpdate = true;
                }
            }
            saveSettings();
            _needsRender = true;
        };

        window.clearAllTrails = function() {
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                plane.userData.trailPoints = [];
                if (plane.userData.trail) {
                    plane.userData.trail.geometry.setDrawRange(0, 0);
                }
            }
            _needsRender = true;
        };

        function init() {
            // Load saved settings from cookies
            loadSettings();

            // Apply loaded settings to UI
            document.body.className = 'theme-' + currentTheme;
            document.getElementById('theme-select').value = currentTheme;
            document.getElementById('units-select').value = currentUnits;

            // Apply altitude scale to slider (1x-300x, internal 100-30000)
            const scaleValue = Math.round(altitudeScale / BASE_ALT_SCALE);
            document.getElementById('altitude-slider').value = scaleValue;
            document.getElementById('altitude-value').textContent = Math.round(scaleValue / 100) + 'x';

            // Apply trail settings to UI
            document.getElementById('btn-trails').classList.toggle('active', trailEnabled);
            document.getElementById('trail-length-slider').value = trailMaxLength;
            document.getElementById('trail-length-value').textContent = trailMaxLength;
            document.getElementById('trail-thickness-slider').value = trailThickness;

            // Apply web data settings to UI
            document.getElementById('source-select').value = currentDataSource;
            document.getElementById('radius-slider').value = viewRadius;
            document.getElementById('radius-value').textContent = viewRadius + ' nm';
            updateDataSourceStatus();

            // Find matching location preset or use custom
            let locationFound = false;
            for (const [key, loc] of Object.entries(PRESET_LOCATIONS)) {
                if (key !== 'custom' && loc.lat === viewLatitude && loc.lon === viewLongitude) {
                    document.getElementById('location-select').value = key;
                    locationFound = true;
                    break;
                }
            }
            if (!locationFound && viewLatitude !== 40.7128) {
                document.getElementById('location-select').value = 'custom';
            }

            // Initialize shared geometry pools
            initSharedGeometries();

            // Scene
            scene = new THREE.Scene();
            updateSceneBackground();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            updateCameraPosition();

            // Renderer - cap pixel ratio at 2 to reduce GPU load on high-DPI displays
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // Ground placeholder
            createGroundPlaceholder();

            // Controls
            setupControls();

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Visibility change - pause rendering when tab is hidden
            document.addEventListener('visibilitychange', () => {
                _isTabVisible = !document.hidden;
            });

            // Mouse interaction
            renderer.domElement.addEventListener('click', onMouseClick);

            // Touch gestures for mobile
            setupTouchControls();

            // Keyboard shortcuts
            setupKeyboardShortcuts();

            // Altitude slider (internal 100-30000, displayed as 1x-300x)
            const slider = document.getElementById('altitude-slider');
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                altitudeScale = value * BASE_ALT_SCALE;
                document.getElementById('altitude-value').textContent = Math.round(value / 100) + 'x';
                updateAllAircraftPositions();
                saveSettings();
            });

            // Start animation
            animate();

            // Fetch data
            fetchData();
            setInterval(fetchData, REFRESH_INTERVAL);

            // Initialize graphs system
            initGraphsSystem();

            // Apply graphs panel state from settings
            if (showGraphs) {
                document.getElementById('graphs-panel').classList.add('visible');
            }

            // Apply time period button state
            document.querySelectorAll('.time-period-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.period) === graphsTimePeriod);
            });

            // Apply trail settings state
            document.getElementById('btn-trails').classList.toggle('active', trailEnabled);
            document.getElementById('trail-length-slider').value = trailMaxLength;
            document.getElementById('trail-length-value').textContent = trailMaxLength;
            document.getElementById('trail-thickness-slider').value = trailThickness;
        }

        function updateSceneBackground() {
            if (currentTheme === 'day') {
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 500, 1200);
            } else if (currentTheme === 'night') {
                scene.background = new THREE.Color(0x0a0a1a);
                scene.fog = new THREE.Fog(0x0a0a1a, 500, 1200);
            } else if (currentTheme === 'retro') {
                scene.background = new THREE.Color(0x000800);
                scene.fog = new THREE.Fog(0x000800, 500, 1200);
            }
        }

        function changeTheme(theme) {
            currentTheme = theme;
            document.body.className = 'theme-' + theme;
            updateSceneBackground();

            // Clear tile cache for theme change to force reload with new style
            tileCache.clear();

            // Reload map tiles with appropriate style
            loadMapTiles();

            // Recreate all airplanes with new style (wireframe vs solid)
            recreateAllAirplanes();

            saveSettings();
        }

        function recreateAllAirplanes() {
            // Store current aircraft data
            const aircraftData = [];
            for (const [hex, plane] of airplanes.entries()) {
                aircraftData.push({...plane.userData});
                // Remove old plane and its trails/lines
                scene.remove(plane);
                if (plane.userData.trail) scene.remove(plane.userData.trail);
                if (plane.userData.altLine) scene.remove(plane.userData.altLine);
            }
            airplanes.clear();
            _airplanesArrayDirty = true;

            // Recreate with new theme style
            for (let i = 0; i < aircraftData.length; i++) {
                const data = aircraftData[i];
                if (!data.lat || !data.lon) continue;
                const plane = createAirplane(data);
                const pos = latLonToXZ(data.lat, data.lon);
                const alt = (data.altitude || 0) * altitudeScale;
                plane.position.set(pos.x, alt, pos.z);

                if (data.track !== undefined) {
                    plane.rotation.y = (-data.track * Math.PI / 180) + Math.PI;
                }

                updateAltitudeLine(plane);
                scene.add(plane);
                airplanes.set(data.hex, plane);
            }
            _airplanesArrayDirty = true;

            updateLabels();
        }

        function changeUnits(units) {
            currentUnits = units;
            updateLabels();
            if (selectedPlane) {
                selectPlane(selectedPlane);
            }
            saveSettings();
        }

        function formatAltitude(altFeet) {
            if (currentUnits === 'imperial') {
                return Math.round(altFeet).toLocaleString() + ' ft';
            } else {
                const meters = Math.round(altFeet * 0.3048);
                return meters.toLocaleString() + ' m';
            }
        }

        function formatSpeed(speedKnots) {
            if (currentUnits === 'imperial') {
                return Math.round(speedKnots) + ' kts';
            } else {
                const kmh = Math.round(speedKnots * 1.852);
                return kmh + ' km/h';
            }
        }

        function formatVertRate(rateFpm) {
            if (currentUnits === 'imperial') {
                return Math.round(rateFpm) + ' ft/min';
            } else {
                const mpm = Math.round(rateFpm * 0.3048);
                return mpm + ' m/min';
            }
        }

        function createGroundPlaceholder() {
            const geometry = new THREE.PlaneGeometry(MAP_GROUND_SIZE, MAP_GROUND_SIZE);
            const material = new THREE.MeshBasicMaterial({
                color: currentTheme === 'retro' ? 0x001100 : 0x1a4d1a,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.name = 'groundPlaceholder';
            scene.add(ground);
        }

        function getTileUrl(x, y, zoom) {
            if (currentTheme === 'retro') {
                // Use Stamen Toner Lite for retro theme - will be inverted to green
                return `https://tiles.stadiamaps.com/tiles/stamen_toner_lite/${zoom}/${x}/${y}.png`;
            } else if (currentTheme === 'night') {
                // Use CartoDB dark tiles for night theme
                return `https://a.basemaps.cartocdn.com/dark_all/${zoom}/${x}/${y}.png`;
            } else {
                // Standard OSM for day theme
                const servers = ['a', 'b', 'c'];
                const server = servers[Math.abs(x + y) % 3];
                return `https://${server}.tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
            }
        }

        // Invert and colorize image for retro theme
        function invertToGreen(image) {
            const canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // Get grayscale value (inverted)
                const gray = 255 - (data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114);
                // Convert to green
                data[i] = 0;           // R
                data[i+1] = gray;      // G
                data[i+2] = 0;         // B
                // Keep alpha
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Initialize shared geometries (called once at startup)
        function initSharedGeometries() {
            if (_sharedGeometries) return;

            _sharedGeometries = {
                // Wireframe geometries (retro theme)
                wire: {
                    fuselage: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.8, 0.6, 4)),
                    nose: new THREE.EdgesGeometry(new THREE.ConeGeometry(0.4, 1.2, 4)),
                    wing: new THREE.EdgesGeometry(new THREE.BoxGeometry(6, 0.1, 1.5)),
                    tail: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.1, 1.2, 0.8)),
                    hStab: new THREE.EdgesGeometry(new THREE.BoxGeometry(2.5, 0.1, 0.5)),
                    light: new THREE.SphereGeometry(0.2, 4, 4),
                    // Helicopter rotor
                    rotor: new THREE.EdgesGeometry(new THREE.BoxGeometry(8, 0.05, 0.3)),
                    rotorMast: new THREE.EdgesGeometry(new THREE.CylinderGeometry(0.1, 0.1, 0.5, 4)),
                    // Small aircraft (prop plane)
                    smallFuselage: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.5, 0.4, 2.5)),
                    smallWing: new THREE.EdgesGeometry(new THREE.BoxGeometry(5, 0.08, 0.8)),
                    propeller: new THREE.EdgesGeometry(new THREE.BoxGeometry(0.1, 1.5, 0.1)),
                    // Wide-body
                    wideFuselage: new THREE.EdgesGeometry(new THREE.BoxGeometry(1.2, 0.9, 5.5)),
                    wideWing: new THREE.EdgesGeometry(new THREE.BoxGeometry(9, 0.12, 2))
                },
                // Solid geometries (day/night themes)
                solid: {
                    fuselage: new THREE.CylinderGeometry(0.4, 0.6, 4, 8),
                    nose: new THREE.ConeGeometry(0.4, 1.2, 8),
                    wing: new THREE.BoxGeometry(5, 0.15, 1.5),
                    tailFin: new THREE.BoxGeometry(0.15, 1.2, 1),
                    hStab: new THREE.BoxGeometry(2, 0.1, 0.6),
                    engine: new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8),
                    light: new THREE.SphereGeometry(0.15, 8, 8),
                    // Helicopter
                    heliFuselage: new THREE.CylinderGeometry(0.4, 0.5, 2.5, 8),
                    heliCabin: new THREE.SphereGeometry(0.6, 8, 6),
                    heliTail: new THREE.CylinderGeometry(0.15, 0.1, 2.5, 6),
                    rotor: new THREE.BoxGeometry(6, 0.05, 0.2),
                    tailRotor: new THREE.BoxGeometry(0.05, 1.2, 0.15),
                    // Small aircraft
                    smallFuselage: new THREE.CylinderGeometry(0.25, 0.35, 2.5, 8),
                    smallWing: new THREE.BoxGeometry(4, 0.08, 0.8),
                    propeller: new THREE.BoxGeometry(0.08, 1.2, 0.08),
                    // Wide-body
                    wideFuselage: new THREE.CylinderGeometry(0.7, 0.8, 5.5, 10),
                    wideNose: new THREE.ConeGeometry(0.7, 1.5, 10),
                    wideWing: new THREE.BoxGeometry(8, 0.2, 2.2),
                    wideEngine: new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8),
                    // Military (angular)
                    milFuselage: new THREE.BoxGeometry(0.6, 0.4, 4.5),
                    milWing: new THREE.BufferGeometry(), // Will be created as triangle
                    milTail: new THREE.BoxGeometry(0.08, 0.8, 0.6)
                },
                // LOD geometries (simplified for distant aircraft)
                lod: {
                    plane: new THREE.BoxGeometry(2, 0.5, 4),
                    light: new THREE.SphereGeometry(0.3, 4, 4)
                },
                // Shared tile geometry
                tile: new THREE.PlaneGeometry(MAP_GROUND_SIZE / TILES_PER_SIDE, MAP_GROUND_SIZE / TILES_PER_SIDE)
            };

            // Create military delta wing geometry
            const milWingVerts = new Float32Array([
                0, 0, -2,    // back center
                -3, 0, 1,   // left front
                3, 0, 1,    // right front
            ]);
            _sharedGeometries.solid.milWing = new THREE.BufferGeometry();
            _sharedGeometries.solid.milWing.setAttribute('position', new THREE.BufferAttribute(milWingVerts, 3));
            _sharedGeometries.solid.milWing.computeVertexNormals();

            // Initialize glow texture for aircraft
            initGlowTexture();
        }

        // Create glow texture for aircraft (sprite-based approach like airloom)
        function initGlowTexture() {
            if (_glowTexture) return;

            // Create radial gradient canvas texture
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Create radial gradient: bright center fading to transparent edges
            const gradient = ctx.createRadialGradient(
                size / 2, size / 2, 0,
                size / 2, size / 2, size / 2
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            _glowTexture = new THREE.CanvasTexture(canvas);
            _glowTexture.needsUpdate = true;
        }

        // Create glow sprite for an aircraft
        function createGlowSprite(color, isRetro) {
            if (!_glowTexture) initGlowTexture();

            const glowMaterial = new THREE.SpriteMaterial({
                map: _glowTexture,
                color: color,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            const glowSprite = new THREE.Sprite(glowMaterial);
            // Scale to 2.5x aircraft size for visible glow effect
            glowSprite.scale.set(8, 8, 1);
            return glowSprite;
        }

        // Get pooled material or create new one
        function getPooledMaterial(type, options) {
            const pool = _materialPool[type];
            if (pool && pool.length > 0) {
                const mat = pool.pop();
                // Reset material properties
                if (options.color !== undefined) mat.color.setHex(options.color);
                if (options.emissive !== undefined && mat.emissive) mat.emissive.setHex(options.emissive);
                if (options.opacity !== undefined) mat.opacity = options.opacity;
                if (options.transparent !== undefined) mat.transparent = options.transparent;
                mat.needsUpdate = true;
                return mat;
            }
            // Create new material
            switch (type) {
                case 'wireframe':
                    return new THREE.LineBasicMaterial(options);
                case 'phong':
                    return new THREE.MeshPhongMaterial(options);
                case 'basic':
                    return new THREE.MeshBasicMaterial(options);
                default:
                    return new THREE.MeshBasicMaterial(options);
            }
        }

        // Return material to pool
        function returnMaterialToPool(type, material) {
            const pool = _materialPool[type];
            if (pool && pool.length < MAX_MATERIAL_POOL_SIZE) {
                pool.push(material);
            } else {
                material.dispose();
            }
        }

        // Tile cache management with size limiting
        function addToTileCache(key, texture) {
            // Enforce cache size limit using LRU-like behavior
            if (tileCache.size >= MAX_TILE_CACHE_SIZE) {
                // Remove oldest entries (first 20% of cache)
                const keysToRemove = [];
                let count = 0;
                const removeCount = Math.floor(MAX_TILE_CACHE_SIZE * 0.2);
                for (const k of tileCache.keys()) {
                    if (count++ < removeCount) {
                        keysToRemove.push(k);
                    } else {
                        break;
                    }
                }
                for (const k of keysToRemove) {
                    const tex = tileCache.get(k);
                    if (tex && tex.dispose) tex.dispose();
                    tileCache.delete(k);
                }
            }
            tileCache.set(key, texture);
        }

        function latLonToTile(lat, lon, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor((lon + 180) / 360 * n);
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y };
        }

        function tileToLatLon(x, y, zoom) {
            const n = Math.pow(2, zoom);
            const lon = x / n * 360 - 180;
            const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
            const lat = latRad * 180 / Math.PI;
            return { lat, lon };
        }

        // Preload tiles for adjacent areas
        function preloadAdjacentTiles() {
            if (!centerInitialized) return;

            const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
            const halfTiles = Math.floor(TILES_PER_SIDE / 2);

            // Preload one tile beyond visible area in each direction
            const preloadRange = halfTiles + 1;

            for (let dy = -preloadRange; dy <= preloadRange; dy++) {
                for (let dx = -preloadRange; dx <= preloadRange; dx++) {
                    // Skip tiles that are already visible
                    if (Math.abs(dx) <= halfTiles && Math.abs(dy) <= halfTiles) continue;

                    const tileX = centerTile.x + dx;
                    const tileY = centerTile.y + dy;
                    const cacheKey = `${currentTheme}-${currentZoom}-${tileX}-${tileY}`;

                    // Skip if already cached or in preload queue
                    if (tileCache.has(cacheKey) || preloadedTiles.has(cacheKey)) continue;

                    preloadQueue.push({ tileX, tileY, cacheKey, zoom: currentZoom, theme: currentTheme });
                }
            }

            // Also preload adjacent zoom levels
            [currentZoom - 1, currentZoom + 1].forEach(zoom => {
                if (zoom < MIN_ZOOM || zoom > MAX_ZOOM) return;
                const ct = latLonToTile(centerLat, centerLon, zoom);
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const tileX = ct.x + dx;
                        const tileY = ct.y + dy;
                        const cacheKey = `${currentTheme}-${zoom}-${tileX}-${tileY}`;
                        if (!tileCache.has(cacheKey) && !preloadedTiles.has(cacheKey)) {
                            preloadQueue.push({ tileX, tileY, cacheKey, zoom, theme: currentTheme });
                        }
                    }
                }
            });

            processPreloadQueue();
        }

        // Process preload queue with concurrency limit
        function processPreloadQueue() {
            while (preloadInProgress < MAX_CONCURRENT_PRELOADS && preloadQueue.length > 0) {
                const item = preloadQueue.shift();
                if (tileCache.has(item.cacheKey) || preloadedTiles.has(item.cacheKey)) continue;

                preloadInProgress++;
                preloadedTiles.set(item.cacheKey, { loading: true });

                const url = getTileUrl(item.tileX, item.tileY, item.zoom);

                if (item.theme === 'retro') {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const invertedCanvas = invertToGreen(img);
                        const texture = new THREE.CanvasTexture(invertedCanvas);
                        addToTileCache(item.cacheKey, texture);
                        preloadedTiles.delete(item.cacheKey);
                        preloadInProgress--;
                        processPreloadQueue();
                    };
                    img.onerror = () => {
                        preloadedTiles.delete(item.cacheKey);
                        preloadInProgress--;
                        processPreloadQueue();
                    };
                    img.src = url;
                } else {
                    const loader = new THREE.TextureLoader();
                    loader.crossOrigin = 'anonymous';
                    loader.load(url,
                        (texture) => {
                            addToTileCache(item.cacheKey, texture);
                            preloadedTiles.delete(item.cacheKey);
                            preloadInProgress--;
                            processPreloadQueue();
                        },
                        undefined,
                        () => {
                            preloadedTiles.delete(item.cacheKey);
                            preloadInProgress--;
                            processPreloadQueue();
                        }
                    );
                }
            }
        }

        function loadMapTiles() {
            if (!centerInitialized) return;

            // Initialize shared geometries if needed
            initSharedGeometries();

            const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
            const halfTiles = Math.floor(TILES_PER_SIDE / 2);
            const startTileX = centerTile.x - halfTiles;
            const startTileY = centerTile.y - halfTiles;
            const topLeft = tileToLatLon(startTileX, startTileY, currentZoom);
            const bottomRight = tileToLatLon(startTileX + TILES_PER_SIDE, startTileY + TILES_PER_SIDE, currentZoom);

            window.mapBounds = {
                north: topLeft.lat,
                south: bottomRight.lat,
                east: bottomRight.lon,
                west: topLeft.lon
            };

            const tileSize = MAP_GROUND_SIZE / TILES_PER_SIDE;

            // Build map of existing tiles by their tile coordinates
            const existingTiles = new Map();
            mapTiles.forEach(tile => {
                if (tile.userData.tileKey) {
                    existingTiles.set(tile.userData.tileKey, tile);
                }
            });

            const newMapTiles = [];
            const tilesToRemove = new Set(existingTiles.keys());

            for (let dy = 0; dy < TILES_PER_SIDE; dy++) {
                for (let dx = 0; dx < TILES_PER_SIDE; dx++) {
                    const tileX = centerTile.x - halfTiles + dx;
                    const tileY = centerTile.y - halfTiles + dy;
                    const cacheKey = `${currentTheme}-${currentZoom}-${tileX}-${tileY}`;
                    const tileKey = `${currentZoom}-${tileX}-${tileY}`;

                    const posX = (dx - halfTiles + 0.5) * tileSize;
                    const posZ = (dy - halfTiles + 0.5) * tileSize;

                    let tile;

                    // Reuse existing tile if same coordinates
                    if (existingTiles.has(tileKey)) {
                        tile = existingTiles.get(tileKey);
                        tilesToRemove.delete(tileKey);
                        // Update position (might change due to different grid position)
                        tile.position.set(posX, 0, posZ);
                    } else {
                        // Create new tile using shared geometry
                        const geometry = _sharedGeometries.tile;
                        const material = new THREE.MeshBasicMaterial({
                            color: currentTheme === 'retro' ? 0x001100 : 0x1a4d1a,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0 // Start transparent for fade-in
                        });

                        tile = new THREE.Mesh(geometry, material);
                        tile.rotation.x = -Math.PI / 2;
                        tile.position.set(posX, 0, posZ);
                        tile.userData.tileKey = tileKey;
                        tile.userData.fadeIn = true;
                        tile.userData.fadeStart = Date.now();
                        scene.add(tile);
                    }

                    newMapTiles.push(tile);

                    // Load or apply texture
                    const material = tile.material;
                    if (tileCache.has(cacheKey)) {
                        material.map = tileCache.get(cacheKey);
                        material.color.setHex(0xffffff);
                        if (!tile.userData.fadeIn) material.opacity = 1;
                        material.needsUpdate = true;
                    } else {
                        // Load texture with fade-in effect
                        loadTileTexture(tileX, tileY, currentZoom, cacheKey, material, tile);
                    }
                }
            }

            // Remove tiles that are no longer needed with fade-out
            for (const tileKey of tilesToRemove) {
                const tile = existingTiles.get(tileKey);
                if (tile) {
                    // Quick fade out and remove
                    tile.userData.fadeOut = true;
                    tile.userData.fadeStart = Date.now();
                    setTimeout(() => {
                        scene.remove(tile);
                        if (tile.material && tile.material !== _sharedGeometries.tile) {
                            tile.material.dispose();
                        }
                    }, 150);
                }
            }

            mapTiles = newMapTiles;
            document.getElementById('map-zoom').textContent = currentZoom;

            // Trigger preloading of adjacent tiles
            setTimeout(preloadAdjacentTiles, 100);

            _needsRender = true;
            updateAllAircraftPositions();
        }

        // Load tile texture with error handling
        function loadTileTexture(tileX, tileY, zoom, cacheKey, material, tile) {
            const url = getTileUrl(tileX, tileY, zoom);

            if (currentTheme === 'retro') {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const invertedCanvas = invertToGreen(img);
                    const texture = new THREE.CanvasTexture(invertedCanvas);
                    material.map = texture;
                    material.color.setHex(0xffffff);
                    material.needsUpdate = true;
                    addToTileCache(cacheKey, texture);
                    tile.userData.textureLoaded = true;
                    _needsRender = true;
                };
                img.onerror = () => {
                    console.warn('Failed to load tile:', url);
                };
                img.src = url;
            } else {
                const loader = new THREE.TextureLoader();
                loader.crossOrigin = 'anonymous';
                loader.load(url,
                    (texture) => {
                        material.color.setHex(0xffffff);
                        material.map = texture;
                        material.needsUpdate = true;
                        addToTileCache(cacheKey, texture);
                        tile.userData.textureLoaded = true;
                        _needsRender = true;
                    },
                    undefined,
                    () => {
                        console.warn('Failed to load tile:', url);
                    }
                );
            }
        }

        function mapZoomIn() {
            if (currentZoom < MAX_ZOOM && !mapTransition.active) {
                startMapTransition(centerLat, centerLon, currentZoom + 1);
            }
        }

        function mapZoomOut() {
            if (currentZoom > MIN_ZOOM && !mapTransition.active) {
                startMapTransition(centerLat, centerLon, currentZoom - 1);
            }
        }

        // Start smooth map transition
        function startMapTransition(targetLat, targetLon, targetZoom) {
            mapTransition.startLat = centerLat;
            mapTransition.startLon = centerLon;
            mapTransition.startZoom = currentZoom;
            mapTransition.targetLat = targetLat;
            mapTransition.targetLon = targetLon;
            mapTransition.targetZoom = targetZoom;
            mapTransition.startTime = Date.now();
            mapTransition.active = true;
            _needsRender = true;
        }

        // Update map transition (called from animate loop)
        function updateMapTransition() {
            if (!mapTransition.active) return false;

            const elapsed = Date.now() - mapTransition.startTime;
            const progress = Math.min(elapsed / mapTransition.duration, 1);
            const easedProgress = mapTransition.easing(progress);

            // Interpolate position
            centerLat = mapTransition.startLat + (mapTransition.targetLat - mapTransition.startLat) * easedProgress;
            centerLon = mapTransition.startLon + (mapTransition.targetLon - mapTransition.startLon) * easedProgress;

            // Update zoom at midpoint for smoother visual effect
            if (progress > 0.3 && currentZoom !== mapTransition.targetZoom) {
                currentZoom = mapTransition.targetZoom;
                loadMapTiles();
            }

            // Update display
            document.getElementById('center-coords').textContent =
                `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;

            // Update map bounds and aircraft positions smoothly
            if (progress < 1) {
                updateMapBoundsSmooth();
                updateAllAircraftPositions();
            }

            if (progress >= 1) {
                mapTransition.active = false;
                centerLat = mapTransition.targetLat;
                centerLon = mapTransition.targetLon;
                currentZoom = mapTransition.targetZoom;
                loadMapTiles();
            }

            return mapTransition.active;
        }

        // Update map bounds during smooth transition
        function updateMapBoundsSmooth() {
            const centerTile = latLonToTile(centerLat, centerLon, currentZoom);
            const halfTiles = Math.floor(TILES_PER_SIDE / 2);
            const startTileX = centerTile.x - halfTiles;
            const startTileY = centerTile.y - halfTiles;
            const topLeft = tileToLatLon(startTileX, startTileY, currentZoom);
            const bottomRight = tileToLatLon(startTileX + TILES_PER_SIDE, startTileY + TILES_PER_SIDE, currentZoom);

            window.mapBounds = {
                north: topLeft.lat,
                south: bottomRight.lat,
                east: bottomRight.lon,
                west: topLeft.lon
            };
        }

        // Map pan function with smooth transition
        function panMap(direction) {
            if (mapTransition.active) return; // Ignore while transitioning

            const zoomFactor = Math.pow(2, 12 - currentZoom);
            const panAmount = 0.05 * zoomFactor;

            let targetLat = centerLat;
            let targetLon = centerLon;

            switch(direction) {
                case 'up': targetLat += panAmount; break;
                case 'down': targetLat -= panAmount; break;
                case 'left': targetLon -= panAmount; break;
                case 'right': targetLon += panAmount; break;
            }

            startMapTransition(targetLat, targetLon, currentZoom);
        }

        function latLonToXZ(lat, lon) {
            if (!window.mapBounds) return { x: 0, z: 0 };
            const bounds = window.mapBounds;
            // X: longitude - West is negative X, East is positive X
            const x = ((lon - bounds.west) / (bounds.east - bounds.west) - 0.5) * MAP_GROUND_SIZE;
            // Z: latitude - North is negative Z, South is positive Z
            // (lat - north) is negative for points north of center, divided by (south - north) which is negative
            // Result: north points get negative Z, south points get positive Z
            const z = ((lat - bounds.north) / (bounds.south - bounds.north) - 0.5) * MAP_GROUND_SIZE;
            return { x, z };
        }

        function getAltitudeColor(altitude) {
            if (currentTheme === 'retro') {
                if (altitude < 5000) return 0x00ff00;
                if (altitude < 15000) return 0x00cc00;
                if (altitude < 30000) return 0x009900;
                return 0x006600;
            }
            if (altitude < 5000) return 0x00ff00;
            if (altitude < 15000) return 0xffff00;
            if (altitude < 30000) return 0xff8800;
            return 0xff0088;
        }

        function createAirplane(data) {
            // Ensure shared geometries are initialized
            if (!_sharedGeometries) initSharedGeometries();

            const group = new THREE.Group();
            const color = getAltitudeColor(data.altitude || 0);
            const isRetro = currentTheme === 'retro';
            const category = getAircraftCategory(data);

            if (isRetro) {
                // WIREFRAME MODE for retro 80s theme
                const wireMat = getPooledMaterial('wireframe', { color: 0x00ff00 });
                let positionLight;

                if (category === 'helicopter') {
                    // Helicopter wireframe
                    const cabin = new THREE.LineSegments(_sharedGeometries.wire.fuselage, wireMat);
                    cabin.scale.set(0.8, 0.8, 0.6);
                    group.add(cabin);

                    const tail = new THREE.LineSegments(_sharedGeometries.wire.fuselage, wireMat.clone());
                    tail.scale.set(0.2, 0.2, 1.2);
                    tail.position.set(0, 0, -1.5);
                    group.add(tail);

                    const mainRotor = new THREE.LineSegments(_sharedGeometries.wire.rotor, wireMat.clone());
                    mainRotor.position.set(0, 0.5, 0);
                    mainRotor.userData.isRotor = true;
                    group.add(mainRotor);

                    const tailRotor = new THREE.LineSegments(_sharedGeometries.wire.rotor, wireMat.clone());
                    tailRotor.scale.set(0.3, 1, 0.3);
                    tailRotor.rotation.z = Math.PI / 2;
                    tailRotor.position.set(0.3, 0, -2.2);
                    group.add(tailRotor);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0.8, 0);
                    group.add(positionLight);
                } else if (category === 'small') {
                    // Small prop plane wireframe
                    const fuselageWire = new THREE.LineSegments(_sharedGeometries.wire.smallFuselage, wireMat);
                    group.add(fuselageWire);

                    const wingWire = new THREE.LineSegments(_sharedGeometries.wire.smallWing, wireMat.clone());
                    group.add(wingWire);

                    const propWire = new THREE.LineSegments(_sharedGeometries.wire.propeller, wireMat.clone());
                    propWire.position.set(0, 0, 1.5);
                    propWire.userData.isProp = true;
                    group.add(propWire);

                    const tailWire = new THREE.LineSegments(_sharedGeometries.wire.tail, wireMat.clone());
                    tailWire.scale.set(0.8, 0.6, 0.6);
                    tailWire.position.set(0, 0.3, -1.2);
                    group.add(tailWire);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0, 1.5);
                    group.add(positionLight);
                } else if (category === 'widebody') {
                    // Wide-body wireframe
                    const fuselageWire = new THREE.LineSegments(_sharedGeometries.wire.wideFuselage, wireMat);
                    group.add(fuselageWire);

                    const noseWire = new THREE.LineSegments(_sharedGeometries.wire.nose, wireMat.clone());
                    noseWire.scale.set(1.4, 1.4, 1.2);
                    noseWire.rotation.x = -Math.PI / 2;
                    noseWire.position.z = 3.5;
                    group.add(noseWire);

                    const wingWire = new THREE.LineSegments(_sharedGeometries.wire.wideWing, wireMat.clone());
                    group.add(wingWire);

                    const tailWire = new THREE.LineSegments(_sharedGeometries.wire.tail, wireMat.clone());
                    tailWire.scale.set(1.2, 1.5, 1.2);
                    tailWire.position.set(0, 0.8, -2.5);
                    group.add(tailWire);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0, 3.5);
                    group.add(positionLight);
                } else {
                    // Default jet wireframe (narrow-body, regional, military)
                    const fuselageWire = new THREE.LineSegments(_sharedGeometries.wire.fuselage, wireMat);
                    group.add(fuselageWire);

                    const noseWire = new THREE.LineSegments(_sharedGeometries.wire.nose, wireMat.clone());
                    noseWire.rotation.x = -Math.PI / 2;
                    noseWire.position.z = 2.6;
                    group.add(noseWire);

                    const wingWire = new THREE.LineSegments(_sharedGeometries.wire.wing, wireMat.clone());
                    if (category === 'military') {
                        wingWire.scale.set(0.8, 1, 1.5); // Swept wings
                    }
                    group.add(wingWire);

                    const tailWire = new THREE.LineSegments(_sharedGeometries.wire.tail, wireMat.clone());
                    tailWire.position.set(0, 0.6, -1.8);
                    group.add(tailWire);

                    const hStabWire = new THREE.LineSegments(_sharedGeometries.wire.hStab, wireMat.clone());
                    hStabWire.position.set(0, 0, -1.8);
                    group.add(hStabWire);

                    const lightMat = getPooledMaterial('basic', { color: 0x00ff00, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.wire.light, lightMat);
                    positionLight.position.set(0, 0, 2.6);
                    group.add(positionLight);
                }

                // Add glow sprite (retro green glow)
                const glowSprite = createGlowSprite(0x00ff00, true);
                glowSprite.position.set(0, 0, 0);
                group.add(glowSprite);

                group.userData = {
                    ...data,
                    category: category,
                    noseMaterial: null,
                    positionLight: positionLight,
                    glowSprite: glowSprite,
                    lightPhase: Math.random() * Math.PI * 2,
                    isWireframe: true
                };
            } else {
                // SOLID MODE for day/night themes
                let positionLight;
                let noseMat, wingMat, fuselageMat;

                if (category === 'helicopter') {
                    // Helicopter solid model
                    fuselageMat = getPooledMaterial('phong', { color: 0xcc0000, emissive: 0x330000 });
                    const cabin = new THREE.Mesh(_sharedGeometries.solid.heliCabin, fuselageMat);
                    group.add(cabin);

                    const tailMat = getPooledMaterial('phong', { color: 0xaa0000, emissive: 0x220000 });
                    const tail = new THREE.Mesh(_sharedGeometries.solid.heliTail, tailMat);
                    tail.rotation.z = Math.PI / 2;
                    tail.position.set(0, -0.1, -1.8);
                    group.add(tail);

                    wingMat = getPooledMaterial('phong', { color: 0x333333, emissive: 0x111111 });
                    const mainRotor = new THREE.Mesh(_sharedGeometries.solid.rotor, wingMat);
                    mainRotor.position.set(0, 0.7, 0);
                    mainRotor.userData.isRotor = true;
                    group.add(mainRotor);

                    const mainRotor2 = new THREE.Mesh(_sharedGeometries.solid.rotor, wingMat);
                    mainRotor2.rotation.y = Math.PI / 2;
                    mainRotor2.position.set(0, 0.7, 0);
                    mainRotor2.userData.isRotor = true;
                    group.add(mainRotor2);

                    const tailRotor = new THREE.Mesh(_sharedGeometries.solid.tailRotor, wingMat);
                    tailRotor.position.set(0.15, 0, -2.8);
                    group.add(tailRotor);

                    noseMat = fuselageMat;
                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.9, 0);
                    group.add(positionLight);
                } else if (category === 'small') {
                    // Small prop plane
                    fuselageMat = getPooledMaterial('phong', { color: 0xffffff, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.smallFuselage, fuselageMat);
                    fuselage.rotation.x = Math.PI / 2;
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: color, emissive: color, emissiveIntensity: 0.3 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.nose, noseMat);
                    nose.scale.set(0.6, 0.6, 0.6);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 1.6;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0xdddddd, emissive: 0x333333 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.smallWing, wingMat);
                    wings.position.y = 0.1;
                    group.add(wings);

                    const propMat = getPooledMaterial('phong', { color: 0x333333 });
                    const prop = new THREE.Mesh(_sharedGeometries.solid.propeller, propMat);
                    prop.position.set(0, 0, 1.8);
                    prop.userData.isProp = true;
                    group.add(prop);

                    const tailFin = new THREE.Mesh(_sharedGeometries.solid.tailFin, wingMat);
                    tailFin.scale.set(0.7, 0.5, 0.6);
                    tailFin.position.set(0, 0.3, -1.2);
                    group.add(tailFin);

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.2, -1);
                    group.add(positionLight);
                } else if (category === 'widebody') {
                    // Wide-body aircraft
                    fuselageMat = getPooledMaterial('phong', { color: 0xffffff, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.wideFuselage, fuselageMat);
                    fuselage.rotation.x = Math.PI / 2;
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: color, emissive: color, emissiveIntensity: 0.3 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.wideNose, noseMat);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 3.5;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0xcccccc, emissive: 0x333333 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.wideWing, wingMat);
                    group.add(wings);

                    const tailFin = new THREE.Mesh(_sharedGeometries.solid.tailFin, wingMat);
                    tailFin.scale.set(1.3, 1.5, 1.3);
                    tailFin.position.set(0, 0.9, -2.5);
                    group.add(tailFin);

                    const engineMat = getPooledMaterial('phong', { color: 0x444444 });
                    [-2.2, -1.1, 1.1, 2.2].forEach(xPos => {
                        const engine = new THREE.Mesh(_sharedGeometries.solid.wideEngine, engineMat);
                        engine.rotation.x = Math.PI / 2;
                        engine.position.set(xPos, -0.4, 0.3);
                        group.add(engine);
                    });

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.4, -2);
                    group.add(positionLight);
                } else if (category === 'military') {
                    // Military aircraft (angular)
                    fuselageMat = getPooledMaterial('phong', { color: 0x556655, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.milFuselage, fuselageMat);
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: 0x445544, emissive: 0x111111 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.nose, noseMat);
                    nose.scale.set(0.7, 0.5, 1.2);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 2.8;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0x556655, emissive: 0x222222 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.milWing, wingMat);
                    wings.scale.set(1.2, 1, 1);
                    group.add(wings);

                    const tail1 = new THREE.Mesh(_sharedGeometries.solid.milTail, wingMat);
                    tail1.position.set(-0.5, 0.4, -2);
                    tail1.rotation.z = 0.3;
                    group.add(tail1);

                    const tail2 = new THREE.Mesh(_sharedGeometries.solid.milTail, wingMat);
                    tail2.position.set(0.5, 0.4, -2);
                    tail2.rotation.z = -0.3;
                    group.add(tail2);

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.3, -1.8);
                    group.add(positionLight);
                } else {
                    // Default narrow-body jet or regional
                    fuselageMat = getPooledMaterial('phong', { color: 0xffffff, emissive: 0x222222 });
                    const fuselage = new THREE.Mesh(_sharedGeometries.solid.fuselage, fuselageMat);
                    fuselage.rotation.x = Math.PI / 2;
                    group.add(fuselage);

                    noseMat = getPooledMaterial('phong', { color: color, emissive: color, emissiveIntensity: 0.3 });
                    const nose = new THREE.Mesh(_sharedGeometries.solid.nose, noseMat);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.z = 2.6;
                    group.add(nose);

                    wingMat = getPooledMaterial('phong', { color: 0xcccccc, emissive: 0x333333 });
                    const wings = new THREE.Mesh(_sharedGeometries.solid.wing, wingMat);
                    group.add(wings);

                    const tailFin = new THREE.Mesh(_sharedGeometries.solid.tailFin, wingMat);
                    tailFin.position.set(0, 0.6, -1.8);
                    group.add(tailFin);

                    const hStab = new THREE.Mesh(_sharedGeometries.solid.hStab, wingMat);
                    hStab.position.set(0, 0, -1.8);
                    group.add(hStab);

                    const engineMat = getPooledMaterial('phong', { color: 0x444444 });
                    [-1.2, 1.2].forEach(xPos => {
                        const engine = new THREE.Mesh(_sharedGeometries.solid.engine, engineMat);
                        engine.rotation.x = Math.PI / 2;
                        engine.position.set(xPos, -0.3, 0.2);
                        group.add(engine);
                    });

                    const lightMat = getPooledMaterial('basic', { color: 0xff0000, transparent: true });
                    positionLight = new THREE.Mesh(_sharedGeometries.solid.light, lightMat);
                    positionLight.position.set(0, 0.3, -1.5);
                    group.add(positionLight);
                }

                // Add glow sprite (color matches altitude)
                const glowSprite = createGlowSprite(color, false);
                glowSprite.position.set(0, 0, 0);
                group.add(glowSprite);

                group.userData = {
                    ...data,
                    category: category,
                    noseMaterial: noseMat,
                    wingMaterial: wingMat,
                    fuselageMaterial: fuselageMat,
                    positionLight: positionLight,
                    glowSprite: glowSprite,
                    lightPhase: Math.random() * Math.PI * 2,
                    isWireframe: false
                };
            }

            // Trail - DO NOT add to scene yet, will be managed separately
            group.userData.trail = null;
            group.userData.trailPoints = [];
            group.userData.trailMaterial = null;

            // Altitude line - also deferred
            group.userData.altLine = null;

            // Distance for LOD calculations
            group.userData.distanceToCamera = 0;

            return group;
        }

        // Create trail line for a plane (airloom-style with smooth curves)
        function createTrailForPlane(plane) {
            if (plane.userData.trail) return; // Already has trail

            const isRetro = currentTheme === 'retro';
            const color = isRetro ? 0x00ff00 : getAltitudeColor(plane.userData.altitude || 0);

            // Use larger buffer for smooth trail with many points
            const trailGeom = new THREE.BufferGeometry();
            const maxPoints = 600; // Enough for smooth curves
            const trailPositions = new Float32Array(maxPoints * 3);
            trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeom.setDrawRange(0, 0);

            const trailMat = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                depthTest: true,
                depthWrite: false,
                linewidth: trailThickness
            });

            const trail = new THREE.Line(trailGeom, trailMat);
            trail.frustumCulled = false;
            trail.renderOrder = 999; // Render after most objects
            trail.visible = trailEnabled;
            scene.add(trail);

            plane.userData.trail = trail;
            plane.userData.trailMaterial = trailMat;
        }

        // Create altitude line for a plane
        function createAltLineForPlane(plane) {
            if (plane.userData.altLine) return;

            const isRetro = currentTheme === 'retro';
            const altLineGeom = new THREE.BufferGeometry();
            const altLinePositions = new Float32Array(6);
            altLineGeom.setAttribute('position', new THREE.BufferAttribute(altLinePositions, 3));
            altLineGeom.setDrawRange(0, 0);

            const altLineMat = new THREE.LineDashedMaterial({
                color: isRetro ? 0x00ff00 : 0x888888,
                dashSize: 2,
                gapSize: 1,
                transparent: true,
                opacity: 0.4
            });

            const altLine = new THREE.Line(altLineGeom, altLineMat);
            scene.add(altLine);

            plane.userData.altLine = altLine;
        }

        async function fetchData() {
            const source = ADSB_SOURCES[currentDataSource];
            if (!source) {
                console.error('Unknown data source:', currentDataSource);
                return;
            }

            try {
                const url = source.getUrl(viewLatitude, viewLongitude, viewRadius);
                const response = await fetch(url, {
                    cache: 'no-store',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const rawData = await response.json();
                const aircraft = source.parseResponse(rawData);
                const now = Date.now();

                // Update data source status
                if (!dataSourceWorking) {
                    dataSourceWorking = true;
                    updateDataSourceStatus();
                }
                lastFetchError = null;

                if (aircraft && aircraft.length > 0) {
                    // Initialize center on first successful fetch
                    if (!centerInitialized) {
                        // Use view location as initial center
                        centerLat = viewLatitude;
                        centerLon = viewLongitude;
                        centerInitialized = true;
                        document.getElementById('center-coords').textContent =
                            `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
                        loadMapTiles();
                    }

                    // Store data in buffer with timestamp
                    aircraft.forEach(ac => {
                        if (!ac.lat || !ac.lon) return;

                        if (!aircraftDataBuffer.has(ac.hex)) {
                            aircraftDataBuffer.set(ac.hex, []);
                        }

                        const buffer = aircraftDataBuffer.get(ac.hex);
                        buffer.push({ timestamp: now, data: {...ac} });

                        // Keep only last 5 seconds of data
                        while (buffer.length > 0 && buffer[0].timestamp < now - 5000) {
                            buffer.shift();
                        }
                    });

                    // Clean up old aircraft
                    const currentHexes = new Set(aircraft.map(ac => ac.hex));
                    for (const [hex, buffer] of aircraftDataBuffer.entries()) {
                        if (!currentHexes.has(hex) && buffer.length > 0) {
                            const lastEntry = buffer[buffer.length - 1];
                            if (now - lastEntry.timestamp > INTERPOLATION_DELAY + 2000) {
                                aircraftDataBuffer.delete(hex);
                            }
                        }
                    }

                    document.getElementById('plane-count').textContent = aircraft.length;
                    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                } else if (!centerInitialized) {
                    // No aircraft yet, still initialize map at view location
                    centerLat = viewLatitude;
                    centerLon = viewLongitude;
                    centerInitialized = true;
                    document.getElementById('center-coords').textContent =
                        `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
                    loadMapTiles();
                    document.getElementById('plane-count').textContent = '0';
                    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                }
            } catch (error) {
                console.error('Error fetching data from', currentDataSource, ':', error);
                lastFetchError = error.message;

                // Try fallback to OpenSky if primary fails
                if (currentDataSource === 'adsb-lol' && dataSourceWorking) {
                    console.log('Trying OpenSky as fallback...');
                    dataSourceWorking = false;
                    updateDataSourceStatus();
                    await tryFallbackSource();
                }
            }
        }

        // Try fallback data source
        async function tryFallbackSource() {
            const fallbackSource = ADSB_SOURCES['opensky'];
            try {
                const url = fallbackSource.getUrl(viewLatitude, viewLongitude, viewRadius);
                const response = await fetch(url, { cache: 'no-store' });

                if (response.ok) {
                    const rawData = await response.json();
                    const aircraft = fallbackSource.parseResponse(rawData);
                    const now = Date.now();

                    if (aircraft && aircraft.length > 0) {
                        // Switch to OpenSky as primary
                        currentDataSource = 'opensky';
                        dataSourceWorking = true;
                        updateDataSourceStatus();
                        console.log('Switched to OpenSky Network');

                        // Initialize map if needed
                        if (!centerInitialized) {
                            centerLat = viewLatitude;
                            centerLon = viewLongitude;
                            centerInitialized = true;
                            document.getElementById('center-coords').textContent =
                                `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
                            loadMapTiles();
                        }

                        // Process aircraft data
                        aircraft.forEach(ac => {
                            if (!ac.lat || !ac.lon) return;
                            if (!aircraftDataBuffer.has(ac.hex)) {
                                aircraftDataBuffer.set(ac.hex, []);
                            }
                            const buffer = aircraftDataBuffer.get(ac.hex);
                            buffer.push({ timestamp: now, data: {...ac} });
                        });

                        document.getElementById('plane-count').textContent = aircraft.length;
                        document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                    }
                }
            } catch (e) {
                console.error('Fallback source also failed:', e);
            }
        }

        // Update data source status indicator
        function updateDataSourceStatus() {
            const statusEl = document.getElementById('data-source-status');
            const infoEl = document.getElementById('data-info');
            const sourceName = ADSB_SOURCES[currentDataSource]?.name || currentDataSource;

            if (statusEl) {
                if (dataSourceWorking) {
                    statusEl.textContent = sourceName;
                    statusEl.className = 'data-status connected';
                } else {
                    statusEl.textContent = 'Connecting...';
                    statusEl.className = 'data-status connecting';
                }
            }

            if (infoEl) {
                infoEl.textContent = sourceName;
            }

            // Also update graphs panel status
            const graphsStatusEl = document.getElementById('graphs-status');
            if (graphsStatusEl) {
                graphsStatusEl.textContent = sourceName;
            }
        }

        // Change data source
        window.changeDataSource = function(source) {
            if (ADSB_SOURCES[source]) {
                currentDataSource = source;
                dataSourceWorking = true;
                lastFetchError = null;
                updateDataSourceStatus();
                saveSettings();

                // Clear existing aircraft and refetch
                aircraftDataBuffer.clear();
                airplanes.forEach((plane, hex) => {
                    scene.remove(plane);
                    if (plane.userData.trail) scene.remove(plane.userData.trail);
                    if (plane.userData.altLine) scene.remove(plane.userData.altLine);
                });
                airplanes.clear();
                _airplanesArrayDirty = true;
                document.getElementById('plane-count').textContent = '0';

                fetchData();
            }
        };

        // Change view location
        window.changeLocation = function(locationKey) {
            const location = PRESET_LOCATIONS[locationKey];
            if (!location) return;

            if (locationKey === 'custom') {
                // Show custom location prompt
                const latInput = prompt('Enter latitude (e.g., 40.7128):', viewLatitude.toString());
                if (latInput === null) return;
                const lonInput = prompt('Enter longitude (e.g., -74.0060):', viewLongitude.toString());
                if (lonInput === null) return;

                const lat = parseFloat(latInput);
                const lon = parseFloat(lonInput);

                if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                    alert('Invalid coordinates. Latitude must be -90 to 90, longitude -180 to 180.');
                    return;
                }

                viewLatitude = lat;
                viewLongitude = lon;
            } else {
                viewLatitude = location.lat;
                viewLongitude = location.lon;
            }

            // Reset and reload with new location
            centerInitialized = false;
            aircraftDataBuffer.clear();

            // Clear existing aircraft
            airplanes.forEach((plane, hex) => {
                scene.remove(plane);
                if (plane.userData.trail) scene.remove(plane.userData.trail);
                if (plane.userData.altLine) scene.remove(plane.userData.altLine);
            });
            airplanes.clear();
            _airplanesArrayDirty = true;

            document.getElementById('plane-count').textContent = '0';
            saveSettings();

            // Update map center
            centerLat = viewLatitude;
            centerLon = viewLongitude;
            centerInitialized = true;
            document.getElementById('center-coords').textContent =
                `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
            loadMapTiles();

            // Update airport markers for new location
            if (showAirports) {
                updateAirportMarkers();
            }

            // Fetch new data
            fetchData();
        };

        // Change view radius
        window.changeRadius = function(radius) {
            viewRadius = parseInt(radius) || 250;
            document.getElementById('radius-value').textContent = viewRadius + ' nm';
            saveSettings();

            // Refetch with new radius
            fetchData();
        };

        // Use browser geolocation
        window.useMyLocation = function() {
            if (!navigator.geolocation) {
                alert('Geolocation is not supported by your browser');
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    viewLatitude = position.coords.latitude;
                    viewLongitude = position.coords.longitude;

                    // Update location selector to custom
                    document.getElementById('location-select').value = 'custom';

                    // Reset and reload
                    centerInitialized = false;
                    aircraftDataBuffer.clear();

                    airplanes.forEach((plane, hex) => {
                        scene.remove(plane);
                        if (plane.userData.trail) scene.remove(plane.userData.trail);
                        if (plane.userData.altLine) scene.remove(plane.userData.altLine);
                    });
                    airplanes.clear();
                    _airplanesArrayDirty = true;

                    centerLat = viewLatitude;
                    centerLon = viewLongitude;
                    centerInitialized = true;
                    document.getElementById('center-coords').textContent =
                        `${centerLat.toFixed(2)}, ${centerLon.toFixed(2)}`;
                    loadMapTiles();

                    saveSettings();
                    fetchData();
                },
                (error) => {
                    alert('Unable to get your location: ' + error.message);
                },
                { enableHighAccuracy: false, timeout: 10000 }
            );
        };

        // Linear interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // Angle interpolation (handles wraparound)
        function lerpAngle(a, b, t) {
            a = ((a % 360) + 360) % 360;
            b = ((b % 360) + 360) % 360;
            let diff = b - a;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return a + diff * t;
        }

        // Reusable object for interpolated data to avoid GC
        const _interpolatedData = {
            hex: '', lat: 0, lon: 0, altitude: 0, track: 0, gs: 0, baro_rate: 0, flight: '', squawk: ''
        };

        // Interpolation function - called at 30fps
        function interpolateAircraft() {
            const now = Date.now();
            const targetTime = now - INTERPOLATION_DELAY;

            // Reuse cached set instead of creating new one
            _seenHexes.clear();

            let planesChanged = false;

            for (const [hex, buffer] of aircraftDataBuffer.entries()) {
                if (buffer.length === 0) continue;

                // Find data points to interpolate between
                let before = null;
                let after = null;

                for (let i = 0; i < buffer.length; i++) {
                    if (buffer[i].timestamp <= targetTime) {
                        before = buffer[i];
                    } else {
                        after = buffer[i];
                        break;
                    }
                }

                if (!before && !after) continue;
                if (!before) before = after;
                if (!after) after = before;

                _seenHexes.add(hex);

                // Calculate interpolation factor
                let t = 0;
                if (before !== after && after.timestamp !== before.timestamp) {
                    t = (targetTime - before.timestamp) / (after.timestamp - before.timestamp);
                    t = Math.max(0, Math.min(1, t));
                }

                // Interpolate data - reuse object to avoid GC
                // Note: dump1090 uses 'gs' for ground speed, 'tas' for true airspeed, 'speed' sometimes
                const beforeSpeed = before.data.gs ?? before.data.speed ?? before.data.tas;
                const afterSpeed = after.data.gs ?? after.data.speed ?? after.data.tas;
                const beforeAlt = before.data.altitude ?? before.data.alt_baro ?? before.data.alt_geom ?? 0;
                const afterAlt = after.data.altitude ?? after.data.alt_baro ?? after.data.alt_geom ?? 0;
                // Support multiple vertical rate field names
                const beforeVertRate = before.data.baro_rate ?? before.data.geom_rate ?? before.data.vert_rate ?? 0;
                const afterVertRate = after.data.baro_rate ?? after.data.geom_rate ?? after.data.vert_rate ?? 0;

                // Populate reusable object
                _interpolatedData.hex = hex;
                _interpolatedData.lat = lerp(before.data.lat, after.data.lat, t);
                _interpolatedData.lon = lerp(before.data.lon, after.data.lon, t);
                _interpolatedData.altitude = lerp(beforeAlt, afterAlt, t);
                _interpolatedData.track = lerpAngle(before.data.track || 0, after.data.track || 0, t);
                _interpolatedData.gs = (beforeSpeed !== undefined && afterSpeed !== undefined) ? lerp(beforeSpeed, afterSpeed, t) : (afterSpeed ?? beforeSpeed);
                _interpolatedData.baro_rate = lerp(beforeVertRate, afterVertRate, t);
                _interpolatedData.flight = after.data.flight || before.data.flight || '';
                _interpolatedData.squawk = after.data.squawk || before.data.squawk || '';

                let plane = airplanes.get(hex);

                if (plane) {
                    // Update existing plane
                    const pos = latLonToXZ(_interpolatedData.lat, _interpolatedData.lon);
                    const alt = _interpolatedData.altitude * altitudeScale;

                    // Store previous position for trail BEFORE updating
                    const prevX = plane.position.x;
                    const prevY = plane.position.y;
                    const prevZ = plane.position.z;

                    // Update position FIRST
                    plane.position.set(pos.x, alt, pos.z);

                    // Update heading
                    if (_interpolatedData.track !== undefined) {
                        plane.rotation.y = (-_interpolatedData.track * Math.PI / 180) + Math.PI;
                    }

                    // Mark plane as initialized after first real position update
                    if (!plane.userData.positionInitialized) {
                        plane.userData.positionInitialized = true;
                        plane.userData.initTime = now;
                    }

                    // Add trail point using lat/lon coordinates (not world coords)
                    // This ensures trails remain valid when map bounds change
                    const timeSinceInit = now - (plane.userData.initTime || now);
                    if (trailEnabled && timeSinceInit > 500) {
                        if (now - (plane.userData.lastTrailTime || 0) > 100) {
                            plane.userData.lastTrailTime = now;

                            // Store as lat/lon/alt - these are stable coordinates
                            const lastPoint = plane.userData.trailPoints[plane.userData.trailPoints.length - 1];
                            const currentLat = plane.userData.lat;
                            const currentLon = plane.userData.lon;
                            const currentAlt = plane.userData.altitude;

                            // Only add if we have valid coordinates and position changed
                            if (currentLat && currentLon) {
                                const dominated = lastPoint &&
                                    Math.abs(lastPoint.lat - currentLat) < 0.0001 &&
                                    Math.abs(lastPoint.lon - currentLon) < 0.0001;

                                if (!dominated) {
                                    plane.userData.trailPoints.push({
                                        lat: currentLat,
                                        lon: currentLon,
                                        alt: currentAlt || 0,
                                        time: now
                                    });
                                    // Keep only the max trail length (airloom-style)
                                    while (plane.userData.trailPoints.length > trailMaxLength) {
                                        plane.userData.trailPoints.shift();
                                    }
                                    // Queue trail update for batching instead of immediate update
                                    if (_trailUpdateQueue.indexOf(plane) === -1) {
                                        _trailUpdateQueue.push(plane);
                                    }
                                }
                            }
                        }
                    }

                    // Update altitude line
                    updateAltitudeLine(plane);

                    // Update colors
                    const newColor = getAltitudeColor(_interpolatedData.altitude);
                    if (plane.userData.noseMaterial) {
                        plane.userData.noseMaterial.color.setHex(newColor);
                        plane.userData.noseMaterial.emissive.setHex(newColor);
                    }
                    if (plane.userData.trailMaterial && currentTheme !== 'retro') {
                        plane.userData.trailMaterial.color.setHex(newColor);
                    }
                    // Update glow color for day/night themes (retro stays green)
                    if (plane.userData.glowSprite && currentTheme !== 'retro') {
                        plane.userData.glowSprite.material.color.setHex(newColor);
                    }

                    // Update userData without creating new object
                    plane.userData.hex = _interpolatedData.hex;
                    plane.userData.lat = _interpolatedData.lat;
                    plane.userData.lon = _interpolatedData.lon;
                    plane.userData.altitude = _interpolatedData.altitude;
                    plane.userData.track = _interpolatedData.track;
                    plane.userData.gs = _interpolatedData.gs;
                    plane.userData.baro_rate = _interpolatedData.baro_rate;
                    plane.userData.flight = _interpolatedData.flight;
                    plane.userData.squawk = _interpolatedData.squawk;
                } else {
                    // Create new plane - need to copy data since we're reusing _interpolatedData
                    const newPlaneData = {
                        hex: _interpolatedData.hex,
                        lat: _interpolatedData.lat,
                        lon: _interpolatedData.lon,
                        altitude: _interpolatedData.altitude,
                        track: _interpolatedData.track,
                        gs: _interpolatedData.gs,
                        baro_rate: _interpolatedData.baro_rate,
                        flight: _interpolatedData.flight,
                        squawk: _interpolatedData.squawk
                    };

                    plane = createAirplane(newPlaneData);
                    const pos = latLonToXZ(newPlaneData.lat, newPlaneData.lon);
                    const alt = newPlaneData.altitude * altitudeScale;

                    // Set position immediately so plane never appears at origin
                    plane.position.set(pos.x, alt, pos.z);

                    if (newPlaneData.track !== undefined) {
                        plane.rotation.y = (-newPlaneData.track * Math.PI / 180) + Math.PI;
                    }

                    // Mark as initialized with current time - trails won't record for 500ms
                    plane.userData.positionInitialized = true;
                    plane.userData.initTime = now;

                    scene.add(plane);
                    airplanes.set(hex, plane);
                    planesChanged = true;

                    // Load trail history from DB
                    loadTrailFromDb(hex, (trailData) => {
                        if (trailData && trailData.points && trailData.points.length > 0 && trailEnabled) {
                            // Restore trail points (limit to max length)
                            plane.userData.trailPoints = trailData.points.slice(-trailMaxLength);
                            updateTrail(plane);
                        }
                    });

                    // Create altitude line after plane is positioned
                    createAltLineForPlane(plane);
                    updateAltitudeLine(plane);
                }
            }

            // Remove planes no longer in data
            for (const [hex, plane] of airplanes.entries()) {
                if (!_seenHexes.has(hex)) {
                    scene.remove(plane);
                    if (plane.userData.trail) scene.remove(plane.userData.trail);
                    if (plane.userData.altLine) scene.remove(plane.userData.altLine);
                    airplanes.delete(hex);
                    planesChanged = true;
                }
            }

            // Mark cached array as dirty if planes were added/removed
            if (planesChanged) {
                _airplanesArrayDirty = true;
                // Apply active filters to new aircraft
                if (searchQuery || filterAltitude || filterSpeed || filterType) {
                    filterAircraft();
                }
                // Update search results count
                document.getElementById('search-results-count').textContent = `${airplanes.size} shown`;
            }
        }

        function updateAltitudeLine(plane) {
            if (!plane.userData.altLine) {
                createAltLineForPlane(plane);
            }

            const altLine = plane.userData.altLine;
            if (!altLine) return;

            // Only draw if plane has valid position
            const absX = plane.position.x < 0 ? -plane.position.x : plane.position.x;
            const absZ = plane.position.z < 0 ? -plane.position.z : plane.position.z;
            if (absX < 0.1 && absZ < 0.1) {
                altLine.geometry.setDrawRange(0, 0);
                return;
            }

            const positions = altLine.geometry.attributes.position.array;
            positions[0] = plane.position.x;
            positions[1] = plane.position.y;
            positions[2] = plane.position.z;
            positions[3] = plane.position.x;
            positions[4] = 0;
            positions[5] = plane.position.z;

            altLine.geometry.attributes.position.needsUpdate = true;
            altLine.geometry.setDrawRange(0, 2);

            // Throttle computeLineDistances - only recompute every 500ms
            const now = Date.now();
            if (!plane.userData._lastLineDistTime || now - plane.userData._lastLineDistTime > 500) {
                plane.userData._lastLineDistTime = now;
                altLine.computeLineDistances();
            }
        }

        function updateAllAircraftPositions() {
            // Use cached array
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                if (plane.userData.lat && plane.userData.lon) {
                    const pos = latLonToXZ(plane.userData.lat, plane.userData.lon);
                    const alt = (plane.userData.altitude || 0) * altitudeScale;
                    plane.position.set(pos.x, alt, pos.z);
                    updateAltitudeLine(plane);
                    // Update trail world positions when map shifts
                    if (plane.userData.trail && plane.userData.trailPoints.length >= 2) {
                        updateTrail(plane);
                    }
                }
            }
            updateLabels();
            _needsRender = true;
        }

        function updateTrail(plane) {
            const points = plane.userData.trailPoints;

            // Need at least 2 valid points to draw a trail
            if (points.length < 2) {
                if (plane.userData.trail) {
                    plane.userData.trail.geometry.setDrawRange(0, 0);
                }
                return;
            }

            // Create trail if needed
            if (!plane.userData.trail) {
                createTrailForPlane(plane);
            }

            const trail = plane.userData.trail;
            if (!trail) return;

            const positions = trail.geometry.attributes.position.array;

            // Convert lat/lon trail points to world coordinates
            const worldPoints = [];
            const maxPoints = Math.min(points.length, trailMaxLength);

            for (let i = 0; i < maxPoints; i++) {
                const pt = points[points.length - maxPoints + i];
                if (pt && pt.lat !== undefined && pt.lon !== undefined) {
                    const worldPos = latLonToXZ(pt.lat, pt.lon);
                    const alt = (pt.alt || 0) * altitudeScale;
                    worldPoints.push(new THREE.Vector3(worldPos.x, alt, worldPos.z));
                }
            }

            // Add current plane position as the final point
            if (plane.userData.lat && plane.userData.lon) {
                worldPoints.push(new THREE.Vector3(plane.position.x, plane.position.y, plane.position.z));
            }

            if (worldPoints.length < 2) {
                trail.geometry.setDrawRange(0, 0);
                return;
            }

            // Use Catmull-Rom curve for smooth interpolation (airloom-style)
            let smoothPoints;
            if (worldPoints.length >= 3) {
                try {
                    const curve = new THREE.CatmullRomCurve3(worldPoints, false, 'centripetal', 0.5);
                    // Get more points for smoother curve (2 per original point)
                    const numSmoothPoints = Math.min(worldPoints.length * 2, 500);
                    smoothPoints = curve.getPoints(numSmoothPoints);
                } catch (e) {
                    // Fallback to original points if curve fails
                    smoothPoints = worldPoints;
                }
            } else {
                smoothPoints = worldPoints;
            }

            // Fill position buffer with smooth points
            const validCount = Math.min(smoothPoints.length, 600);
            for (let i = 0; i < validCount; i++) {
                const pt = smoothPoints[i];
                const idx = i * 3;
                positions[idx] = pt.x;
                positions[idx + 1] = pt.y;
                positions[idx + 2] = pt.z;
            }

            // Update trail color based on current altitude
            if (plane.userData.trailMaterial && trailColorMode === 'altitude') {
                const isRetro = currentTheme === 'retro';
                const newColor = isRetro ? 0x00ff00 : getAltitudeColor(plane.userData.altitude || 0);
                plane.userData.trailMaterial.color.setHex(newColor);
            }

            trail.geometry.attributes.position.needsUpdate = true;
            trail.geometry.setDrawRange(0, validCount);
            _needsRender = true;

            // Save trail to DB periodically (every 10 seconds)
            if (!plane.userData.lastTrailSave || Date.now() - plane.userData.lastTrailSave > 10000) {
                plane.userData.lastTrailSave = Date.now();
                saveTrailToDb(plane.userData.hex, plane.userData.trailPoints, plane.userData.lat, plane.userData.lon);
            }
        }

        // Get vertical speed arrow character and size
        // baro_rate is in ft/min, we need to convert to m/s for sizing
        // 2 m/s = 393.7 ft/min (minimum threshold)
        // 20 m/s = 3937 ft/min (maximum size)
        function getVerticalSpeedArrow(baroRate) {
            if (baroRate === undefined || baroRate === null) return null;

            // Convert ft/min to m/s (divide by 196.85)
            const vertSpeedMs = Math.abs(baroRate) / 196.85;

            // Ignore vertical speeds below 2 m/s
            if (vertSpeedMs < 2) return null;

            // Cap at 20 m/s for sizing
            const clampedSpeed = Math.min(vertSpeedMs, 20);

            // Scale arrow size: 2 m/s -> 16px, 20 m/s -> 48px (linear)
            const arrowSize = 16 + ((clampedSpeed - 2) / 18) * 32;

            const arrow = baroRate > 0 ? '‚Üë' : '‚Üì';
            const color = baroRate > 0 ? '#44ff44' : '#ff6644';

            return { arrow, size: arrowSize, color };
        }

        // Get a canvas from pool or create new one
        function _getPooledCanvas() {
            if (_labelCanvasPool.length > 0) {
                return _labelCanvasPool.pop();
            }
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 80;
            return canvas;
        }

        // Return canvas to pool
        function _returnCanvasToPool(canvas) {
            if (_labelCanvasPool.length < MAX_LABEL_POOL_SIZE) {
                _labelCanvasPool.push(canvas);
            }
        }

        // Render label content to canvas
        function _renderLabelToCanvas(ctx, plane) {
            // Clear canvas
            ctx.clearRect(0, 0, 256, 80);

            const isRetro = currentTheme === 'retro';
            const isNight = currentTheme === 'night';

            // Background with theme styling
            if (isRetro) {
                ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
            } else if (isNight) {
                ctx.fillStyle = 'rgba(0, 20, 40, 0.85)';
                ctx.strokeStyle = '#0088ff';
                ctx.lineWidth = 1;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = '#0066cc';
                ctx.lineWidth = 1;
            }
            ctx.beginPath();
            ctx.roundRect(0, 0, 256, 80, 8);
            ctx.fill();
            ctx.stroke();

            // Category icon (left side)
            const category = plane.userData.category || 'jet';
            const categoryIcons = {
                'helicopter': 'üöÅ',
                'military': 'üéñÔ∏è',
                'widebody': 'üõ´',
                'small': 'üõ©Ô∏è',
                'regional': 'üõ©Ô∏è',
                'jet': '‚úàÔ∏è'
            };
            ctx.font = '16px sans-serif';
            ctx.fillText(categoryIcons[category] || '‚úàÔ∏è', 8, 22);

            // Emergency squawk indicator (right side)
            const squawk = plane.userData.squawk || '';
            if (['7500', '7600', '7700'].includes(squawk)) {
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText('‚ö†Ô∏è' + squawk, 248, 16);
                ctx.textAlign = 'left';
            }

            // Callsign (main text)
            ctx.fillStyle = isRetro ? '#00ff00' : (isNight ? '#00ffff' : '#0066cc');
            ctx.font = 'bold 22px monospace';
            const callsign = plane.userData.flight || plane.userData.hex || 'Unknown';
            ctx.fillText(callsign.trim(), 30, 28);

            // Altitude
            ctx.fillStyle = isRetro ? '#00cc00' : (isNight ? '#88ff88' : '#006600');
            ctx.font = '16px monospace';
            ctx.fillText(formatAltitude(plane.userData.altitude || 0), 10, 50);

            // Speed
            if (plane.userData.gs !== undefined && plane.userData.gs !== null) {
                ctx.fillStyle = isRetro ? '#00aa00' : (isNight ? '#ffaa00' : '#cc6600');
                ctx.fillText(formatSpeed(plane.userData.gs), 10, 70);
            }

            // Draw vertical speed arrow on the right side
            const arrowInfo = getVerticalSpeedArrow(plane.userData.baro_rate);
            if (arrowInfo) {
                ctx.fillStyle = isRetro ? '#00ff00' : arrowInfo.color;
                ctx.font = `bold ${Math.round(arrowInfo.size)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(arrowInfo.arrow, 230, 50);
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
            }
        }

        function updateLabels() {
            // Return old canvases to pool and collect sprites for reuse
            const oldSprites = [];
            for (let i = 0; i < labels.length; i++) {
                const label = labels[i];
                scene.remove(label);
                // Return canvas to pool if it exists
                if (label.material && label.material.map && label.material.map.image) {
                    _returnCanvasToPool(label.material.map.image);
                }
                oldSprites.push(label);
            }
            labels.length = 0;

            // Clear label references from planes
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            for (let i = 0; i < _airplanesArray.length; i++) {
                _airplanesArray[i].userData.label = null;
            }

            if (!showLabels) return;

            let spriteIndex = 0;
            for (let i = 0; i < _airplanesArray.length; i++) {
                const plane = _airplanesArray[i];

                // Skip labels for distant aircraft (LOD culling)
                const dist = plane.userData.distanceToCamera || 0;
                if (dist > LOD_DISTANCE_CULL) {
                    plane.userData.label = null;
                    continue;
                }

                const canvas = _getPooledCanvas();
                const ctx = canvas.getContext('2d');

                _renderLabelToCanvas(ctx, plane);

                let sprite;
                if (spriteIndex < oldSprites.length) {
                    // Reuse existing sprite
                    sprite = oldSprites[spriteIndex];
                    sprite.material.map.image = canvas;
                    sprite.material.map.needsUpdate = true;
                } else {
                    // Create new sprite
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    sprite = new THREE.Sprite(material);
                    sprite.scale.set(15, 4.7, 1);
                }
                spriteIndex++;

                sprite.position.copy(plane.position);
                sprite.position.y += 8;
                sprite.visible = true;

                // Scale labels based on distance
                if (dist > LOD_DISTANCE_FAR) {
                    const scale = 1 - (dist - LOD_DISTANCE_FAR) / (LOD_DISTANCE_CULL - LOD_DISTANCE_FAR) * 0.4;
                    sprite.scale.set(15 * scale, 4.7 * scale, 1);
                } else {
                    sprite.scale.set(15, 4.7, 1);
                }

                // Store reference to label on the plane for correct position updates
                plane.userData.label = sprite;

                scene.add(sprite);
                labels.push(sprite);
            }

            // Dispose unused old sprites
            for (let i = spriteIndex; i < oldSprites.length; i++) {
                const sprite = oldSprites[i];
                if (sprite.material) {
                    if (sprite.material.map) sprite.material.map.dispose();
                    sprite.material.dispose();
                }
            }
        }

        // Camera controls
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                // Left (0) or Middle (1) drag pans the map
                if (e.button === 0 || e.button === 1) {
                    e.preventDefault();
                    isPanningMap = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    return;
                }
                // Right (2) drag orbits camera (optional)
                if (e.button === 2) {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                // Map pan when left/middle mouse held
                if (isPanningMap) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    panMapByPixels(deltaX, deltaY);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    return;
                }
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngle += deltaX * 0.01;
                cameraHeight = Math.max(10, Math.min(300, cameraHeight - deltaY * 0.5));

                updateCameraPosition();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', (e) => {
                if (e.button === 0 || e.button === 1) {
                    isPanningMap = false;
                }
                if (e.button === 2) {
                    isDragging = false;
                }
            });
            renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; isPanningMap = false; });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                // When following aircraft, wheel adjusts follow zoom; otherwise zoom map
                if (followSelectedPlane) {
                    const factor = e.deltaY > 0 ? 1.1 : 0.9; // scroll down = out, up = in
                    followZoom = Math.max(0.3, Math.min(5, followZoom * factor));
                } else {
                    if (e.deltaY < 0) mapZoomIn(); else mapZoomOut();
                }
                _needsRender = true;
            }, { passive: false });
        }

        // Middle mouse drag ‚Üí smooth map pan based on pixel delta
        let isPanningMap = false;
        function panMapByPixels(dx, dy) {
            if (!centerInitialized) return;
            // Scale pan speed by zoom (higher zoom ‚Üí smaller movement)
            const zoomFactor = Math.pow(2, 12 - currentZoom);
            const base = 0.00015 * zoomFactor; // tuned for comfortable drag
            const targetLat = centerLat - (dy * base);
            const targetLon = centerLon + (dx * base);
            startMapTransition(targetLat, targetLon, currentZoom);
        }

        function updateCameraPosition() {
            camera.position.x = Math.sin(cameraAngle) * cameraDistance;
            camera.position.z = Math.cos(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.lookAt(0, cameraHeight * 0.2, 0);
            _needsRender = true;
        }

        function resetCamera() {
            cameraAngle = 0;
            cameraHeight = 80;
            cameraDistance = 150;
            updateCameraPosition();
        }

        function cameraZoomIn() {
            cameraDistance = Math.max(30, cameraDistance - 20);
            updateCameraPosition();
        }

        function cameraZoomOut() {
            cameraDistance = Math.min(500, cameraDistance + 20);
            updateCameraPosition();
        }

        // Smooth rotation
        let rotateDirection = null;
        let rotateInterval = null;

        function startRotate(direction) {
            rotateDirection = direction;
            if (rotateInterval) clearInterval(rotateInterval);
            rotateInterval = setInterval(() => {
                if (rotateDirection === 'left') {
                    cameraAngle -= 0.02;
                } else if (rotateDirection === 'right') {
                    cameraAngle += 0.02;
                }
                updateCameraPosition();
            }, 16);
        }

        function stopRotate() {
            rotateDirection = null;
            if (rotateInterval) {
                clearInterval(rotateInterval);
                rotateInterval = null;
            }
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('btn-rotate').classList.toggle('active', autoRotate);
            saveSettings();
        }

        function toggleLabels() {
            showLabels = !showLabels;
            document.getElementById('btn-labels').classList.toggle('active', showLabels);
            updateLabels();
            saveSettings();
        }

        function onMouseClick(event) {
            // Reuse cached objects to avoid GC pressure
            _mouseVec.x = (event.clientX / window.innerWidth) * 2 - 1;
            _mouseVec.y = -(event.clientY / window.innerHeight) * 2 + 1;

            _raycaster.setFromCamera(_mouseVec, camera);

            // Use cached array if available
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            const intersects = _raycaster.intersectObjects(_airplanesArray, true);

            if (intersects.length > 0) {
                let plane = intersects[0].object;
                while (plane.parent && !plane.userData.hex) {
                    plane = plane.parent;
                }
                if (plane.userData.hex) {
                    selectPlane(plane);
                    // Auto-follow when a plane is selected via click
                    followSelectedPlane = true;
                    updateFollowButtons?.();
                }
            } else {
                deselectPlane();
            }
            _needsRender = true;
        }

        function selectPlane(plane) {
            selectedPlane = plane;
            const panel = document.getElementById('selected-plane');
            panel.style.display = 'block';

            document.getElementById('sel-callsign').textContent = plane.userData.flight || plane.userData.hex || '--';
            document.getElementById('sel-altitude').textContent = formatAltitude(plane.userData.altitude || 0);
            document.getElementById('sel-speed').textContent = (plane.userData.gs !== undefined && plane.userData.gs !== null) ? formatSpeed(plane.userData.gs) : '--';
            document.getElementById('sel-track').textContent = (plane.userData.track || '--') + '¬∞';
            document.getElementById('sel-vertrate').textContent = plane.userData.baro_rate ? formatVertRate(plane.userData.baro_rate) : '--';
            document.getElementById('sel-squawk').textContent = plane.userData.squawk || '--';
            document.getElementById('sel-position').textContent =
                `${(plane.userData.lat || 0).toFixed(4)}¬∞, ${(plane.userData.lon || 0).toFixed(4)}¬∞`;

            // Fetch and display enriched aircraft information
            updateEnrichedInfo(plane);
        }

        function deselectPlane() {
            selectedPlane = null;
            followSelectedPlane = false;
            document.getElementById('selected-plane').style.display = 'none';
            document.getElementById('aircraft-enriched-info').classList.remove('visible');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            _needsRender = true;
        }

        let time = 0;
        let lastLabelUpdate = 0;
        const INTERPOLATION_INTERVAL = 1000 / INTERPOLATION_FPS;

        // Update tile fade animations
        function updateTileFades(now) {
            let anyFading = false;
            const FADE_DURATION = 200; // ms

            for (let i = 0; i < mapTiles.length; i++) {
                const tile = mapTiles[i];
                if (!tile.material) continue;

                if (tile.userData.fadeIn) {
                    const elapsed = now - tile.userData.fadeStart;
                    const progress = Math.min(elapsed / FADE_DURATION, 1);
                    tile.material.opacity = progress;

                    if (progress >= 1) {
                        tile.userData.fadeIn = false;
                        tile.material.transparent = false;
                        tile.material.opacity = 1;
                    } else {
                        anyFading = true;
                    }
                    tile.material.needsUpdate = true;
                }

                if (tile.userData.fadeOut) {
                    const elapsed = now - tile.userData.fadeStart;
                    const progress = Math.min(elapsed / (FADE_DURATION * 0.75), 1);
                    tile.material.opacity = 1 - progress;
                    tile.material.needsUpdate = true;
                    anyFading = true;
                }
            }

            return anyFading;
        }

        // Calculate distance from camera to plane for LOD
        function updateDistances() {
            const camPos = camera.position;
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];
                const dx = plane.position.x - camPos.x;
                const dy = plane.position.y - camPos.y;
                const dz = plane.position.z - camPos.z;
                plane.userData.distanceToCamera = Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Skip rendering when tab is not visible to save CPU/power
            if (!_isTabVisible) return;

            const now = Date.now();
            time += 0.016;

            // Update map transitions
            const isTransitioning = updateMapTransition();
            if (isTransitioning) _needsRender = true;

            // Run interpolation at 30fps
            if (now - lastInterpolationTime >= INTERPOLATION_INTERVAL) {
                lastInterpolationTime = now;
                interpolateAircraft();
                _needsRender = true;
            }

            if (autoRotate) {
                cameraAngle += 0.002;
                updateCameraPosition();
                _needsRender = true;
            }

            // Update tile fade animations
            if (updateTileFades(now)) {
                _needsRender = true;
            }

            // Update cached array if needed
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }

            // Update distances for LOD (every few frames)
            if ((now % 3) === 0) {
                updateDistances();
            }

            const needsLabelRedraw = now - lastLabelUpdate > 1000;
            const updateLabelPositions = !needsLabelRedraw && showLabels;

            // Single combined loop for lights, rotors, and label positions
            let anyLightChange = false;
            for (let i = 0, len = _airplanesArray.length; i < len; i++) {
                const plane = _airplanesArray[i];

                // Animate position lights
                if (plane.userData.positionLight) {
                    plane.userData.lightPhase += 0.08;
                    const brightness = Math.sin(plane.userData.lightPhase) > 0.7 ? 1 : 0.2;
                    const currentOpacity = plane.userData.positionLight.material.opacity;

                    // Only update if brightness changed significantly
                    if (Math.abs(currentOpacity - brightness) > 0.3) {
                        plane.userData.positionLight.material.opacity = brightness;
                        anyLightChange = true;
                    }
                }

                // Animate glow sprite (subtle pulsing synced with position lights)
                if (plane.userData.glowSprite) {
                    const glowPulse = 0.3 + 0.15 * Math.sin(plane.userData.lightPhase * 0.5);
                    const glowScale = 7 + 1.5 * Math.sin(plane.userData.lightPhase * 0.3);
                    plane.userData.glowSprite.material.opacity = glowPulse;
                    plane.userData.glowSprite.scale.set(glowScale, glowScale, 1);
                    anyLightChange = true;
                }

                // Animate rotors and propellers
                if (plane.userData.category === 'helicopter' || plane.userData.category === 'small') {
                    plane.children.forEach(child => {
                        if (child.userData && child.userData.isRotor) {
                            child.rotation.y += 0.5; // Fast rotation for helicopter rotor
                            anyLightChange = true;
                        }
                        if (child.userData && child.userData.isProp) {
                            child.rotation.z += 0.4; // Propeller rotation
                            anyLightChange = true;
                        }
                    });
                }

                // Update label positions between full redraws
                if (updateLabelPositions && plane.userData.label) {
                    // Distance-based label culling
                    const dist = plane.userData.distanceToCamera || 0;
                    if (dist > LOD_DISTANCE_CULL) {
                        plane.userData.label.visible = false;
                    } else {
                        plane.userData.label.visible = true;
                        plane.userData.label.position.x = plane.position.x;
                        plane.userData.label.position.y = plane.position.y + 8;
                        plane.userData.label.position.z = plane.position.z;

                        // Scale labels based on distance
                        if (dist > LOD_DISTANCE_FAR) {
                            const scale = 1 - (dist - LOD_DISTANCE_FAR) / (LOD_DISTANCE_CULL - LOD_DISTANCE_FAR) * 0.4;
                            plane.userData.label.scale.set(15 * scale, 4.7 * scale, 1);
                        }
                    }
                }
            }

            if (anyLightChange) _needsRender = true;

            // Update labels periodically - redraw every 1 second to update speed/altitude
            if (needsLabelRedraw) {
                lastLabelUpdate = now;
                updateLabels();
                _needsRender = true;

                if (selectedPlane && airplanes.has(selectedPlane.userData.hex)) {
                    selectPlane(airplanes.get(selectedPlane.userData.hex));
                }
            }

            // Process batched trail updates
            if (now - _lastBatchTrailUpdate >= BATCH_TRAIL_INTERVAL && _trailUpdateQueue.length > 0) {
                _lastBatchTrailUpdate = now;
                const batch = _trailUpdateQueue.splice(0, 10); // Process 10 at a time
                for (let i = 0; i < batch.length; i++) {
                    updateTrail(batch[i]);
                }
                _needsRender = true;
            }

            // Update stats panel (every 2 seconds)
            if (showStats && (now % 2000) < 100) {
                updateStatsPanel();
            }

            // Update follow mode
            updateFollowMode();

            // Update camera follow modes
            updateFollowCamera();

            // Update prediction lines for visible aircraft
            if (showPrediction && (now % 500) < 100) {
                for (const plane of _airplanesArray) {
                    if (plane.visible) {
                        updatePredictionLine(plane);
                    }
                }
            }

            // Check aircraft alerts (every 2 seconds)
            if (alertsEnabled && (now % 2000) < 100) {
                for (const plane of _airplanesArray) {
                    checkAircraftAlerts(plane);
                }
            }

            // Record flight history (every 5 seconds)
            if ((now % 5000) < 100) {
                for (const plane of _airplanesArray) {
                    recordFlightHistory(plane);
                }
            }

            // Render only when needed (or throttle to max fps)
            if (_needsRender || now - _renderThrottleTime > RENDER_THROTTLE_MS) {
                renderer.render(scene, camera);
                _renderThrottleTime = now;
                _needsRender = false;
            }
        }

        // ===========================================
        // KEYBOARD SHORTCUTS
        // ===========================================
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

                const key = e.key.toLowerCase();

                // Help overlay toggle
                if (key === '?' || (key === '/' && e.shiftKey)) {
                    toggleKeyboardHelp();
                    e.preventDefault();
                    return;
                }

                // Close help or deselect with Escape
                if (key === 'escape') {
                    if (document.getElementById('keyboard-help').classList.contains('visible')) {
                        toggleKeyboardHelp();
                    } else if (selectedPlane) {
                        deselectPlane();
                    }
                    e.preventDefault();
                    return;
                }

                // Navigation - Arrow keys for map pan
                if (key === 'arrowup') { panMap('up'); e.preventDefault(); }
                if (key === 'arrowdown') { panMap('down'); e.preventDefault(); }
                if (key === 'arrowleft') { panMap('left'); e.preventDefault(); }
                if (key === 'arrowright') { panMap('right'); e.preventDefault(); }

                // Camera zoom
                if (key === '+' || key === '=') { cameraZoomIn(); e.preventDefault(); }
                if (key === '-' || key === '_') { cameraZoomOut(); e.preventDefault(); }

                // Camera rotate
                if (key === '[') { cameraAngle -= 0.1; updateCameraPosition(); e.preventDefault(); }
                if (key === ']') { cameraAngle += 0.1; updateCameraPosition(); e.preventDefault(); }

                // Reset camera
                if (key === 'r' && !e.ctrlKey && !e.metaKey) { resetCamera(); e.preventDefault(); }

                // Map zoom with M key
                if (key === 'm') {
                    // Wait for next key
                    const handleMapZoom = (e2) => {
                        if (e2.key === '+' || e2.key === '=') mapZoomIn();
                        if (e2.key === '-' || e2.key === '_') mapZoomOut();
                        document.removeEventListener('keydown', handleMapZoom);
                    };
                    document.addEventListener('keydown', handleMapZoom, { once: true });
                    e.preventDefault();
                }

                // Toggle labels
                if (key === 'l') { toggleLabels(); e.preventDefault(); }

                // Toggle graphs
                if (key === 'g') { toggleGraphs(); e.preventDefault(); }

                // Toggle auto-rotate
                if (key === 'a') { toggleAutoRotate(); e.preventDefault(); }

                // Toggle trails
                if (key === 't' && !e.ctrlKey) { toggleTrails(); e.preventDefault(); }

                // Clear all trails
                if (key === 'c' && !e.ctrlKey && !e.metaKey) { clearAllTrails(); e.preventDefault(); }

                // Toggle stats panel
                if (key === 's') { toggleStats(); e.preventDefault(); }

                // Theme switching
                if (key === '1') { changeTheme('day'); e.preventDefault(); }
                if (key === '2') { changeTheme('night'); e.preventDefault(); }
                if (key === '3') { changeTheme('retro'); e.preventDefault(); }

                // Aircraft selection with Tab
                if (key === 'tab') {
                    e.preventDefault();
                    selectNextAircraft(e.shiftKey ? -1 : 1);
                }

                // Follow selected aircraft
                if (key === 'f' && selectedPlane) {
                    followSelectedPlane = !followSelectedPlane;
                    e.preventDefault();
                }

                // Search/Filter shortcuts
                if (key === '/' && !e.shiftKey) {
                    document.getElementById('search-input').focus();
                    e.preventDefault();
                }

                // Export shortcut
                if (key === 'e' && !e.ctrlKey && !e.metaKey) {
                    toggleExportPanel();
                    e.preventDefault();
                }

                // Airport markers
                if (key === 'p') {
                    toggleAirports();
                    e.preventDefault();
                }

                // Prediction lines
                if (key === 'n') {
                    togglePrediction();
                    e.preventDefault();
                }
            });
        }

        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            help.classList.toggle('visible');
        }

        function selectNextAircraft(direction) {
            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }
            if (_airplanesArray.length === 0) return;

            let currentIndex = -1;
            if (selectedPlane) {
                currentIndex = _airplanesArray.findIndex(p => p.userData.hex === selectedPlane.userData.hex);
            }

            let nextIndex = currentIndex + direction;
            if (nextIndex < 0) nextIndex = _airplanesArray.length - 1;
            if (nextIndex >= _airplanesArray.length) nextIndex = 0;

            selectPlane(_airplanesArray[nextIndex]);
        }

        // ===========================================
        // MOBILE TOUCH CONTROLS
        // ===========================================
        function setupTouchControls() {
            const canvas = renderer.domElement;

            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                isTwoFingerGesture = true;

                // Calculate initial distance and angle for pinch/rotate
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                touchStartAngle = Math.atan2(dy, dx);

                // Store center point
                lastTouchCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            } else if (e.touches.length === 1) {
                isTwoFingerGesture = false;
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2 && isTwoFingerGesture) {
                e.preventDefault();

                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                const currentAngle = Math.atan2(dy, dx);

                // Pinch to zoom
                const distanceRatio = currentDistance / touchStartDistance;
                if (Math.abs(distanceRatio - 1) > 0.01) {
                    const zoomDelta = (1 - distanceRatio) * 50;
                    cameraDistance = Math.max(30, Math.min(500, cameraDistance + zoomDelta));
                    touchStartDistance = currentDistance;
                    updateCameraPosition();
                }

                // Two-finger rotate
                const angleDelta = currentAngle - touchStartAngle;
                if (Math.abs(angleDelta) > 0.01) {
                    cameraAngle += angleDelta;
                    touchStartAngle = currentAngle;
                    updateCameraPosition();
                }

                // Two-finger pan
                const currentCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                const panDeltaX = currentCenter.x - lastTouchCenter.x;
                const panDeltaY = currentCenter.y - lastTouchCenter.y;

                if (Math.abs(panDeltaX) > 10) {
                    panMap(panDeltaX > 0 ? 'right' : 'left');
                    lastTouchCenter.x = currentCenter.x;
                }
                if (Math.abs(panDeltaY) > 10) {
                    panMap(panDeltaY > 0 ? 'down' : 'up');
                    lastTouchCenter.y = currentCenter.y;
                }

                _needsRender = true;
            } else if (e.touches.length === 1 && !isTwoFingerGesture) {
                // Single finger drag for camera orbit
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                cameraAngle += deltaX * 0.01;
                cameraHeight = Math.max(10, Math.min(300, cameraHeight - deltaY * 0.5));

                updateCameraPosition();
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                isTwoFingerGesture = false;
            }
            if (e.touches.length === 1) {
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }

        // ===========================================
        // STATS PANEL FUNCTIONS (integrated in info-panel)
        // ===========================================
        window.toggleStats = function() {
            showStats = !showStats;
            const section = document.getElementById('stats-section');
            const btn = document.getElementById('btn-stats');

            if (showStats) {
                section.classList.add('visible');
                btn.classList.add('active');
                updateStatsPanel();
            } else {
                section.classList.remove('visible');
                btn.classList.remove('active');
            }
        };

        function updateStatsPanel() {
            if (!showStats) return;

            // Update unique aircraft count
            document.getElementById('stats-total-tracked').textContent = uniqueAircraftSeen.size;
            document.getElementById('stats-max-concurrent').textContent = maxConcurrentAircraft;

            // Calculate average altitude
            let totalAlt = 0, altCount = 0;
            const altBuckets = [0, 0, 0, 0, 0]; // <5k, 5-15k, 15-30k, 30-40k, >40k

            if (_airplanesArrayDirty) {
                _airplanesArray = Array.from(airplanes.values());
                _airplanesArrayDirty = false;
            }

            for (const plane of _airplanesArray) {
                const alt = plane.userData.altitude || 0;
                totalAlt += alt;
                altCount++;

                // Bucket altitude
                if (alt < 5000) altBuckets[0]++;
                else if (alt < 15000) altBuckets[1]++;
                else if (alt < 30000) altBuckets[2]++;
                else if (alt < 40000) altBuckets[3]++;
                else altBuckets[4]++;

                // Track unique aircraft
                if (plane.userData.hex) {
                    uniqueAircraftSeen.add(plane.userData.hex);
                }

                // Track aircraft types (if available)
                const flight = plane.userData.flight || '';
                if (flight) {
                    const airline = flight.substring(0, 3);
                    aircraftTypeStats.set(airline, (aircraftTypeStats.get(airline) || 0) + 1);
                }

                // Update coverage heatmap
                if (plane.userData.lat && plane.userData.lon && window.mapBounds) {
                    const bounds = window.mapBounds;
                    const normX = (plane.userData.lon - bounds.west) / (bounds.east - bounds.west);
                    const normY = (plane.userData.lat - bounds.south) / (bounds.north - bounds.south);
                    if (normX >= 0 && normX < 1 && normY >= 0 && normY < 1) {
                        const gridX = Math.floor(normX * 20);
                        const gridY = Math.floor(normY * 20);
                        const idx = gridY * 20 + gridX;
                        coverageHeatmap[idx] = Math.min(255, coverageHeatmap[idx] + 1);
                    }
                }
            }

            // Update max concurrent
            if (_airplanesArray.length > maxConcurrentAircraft) {
                maxConcurrentAircraft = _airplanesArray.length;
            }

            // Display average altitude
            const avgAlt = altCount > 0 ? Math.round(totalAlt / altCount) : 0;
            document.getElementById('stats-avg-altitude').textContent = formatAltitude(avgAlt);

            // Calculate data quality (% with position)
            let withPosition = 0;
            for (const plane of _airplanesArray) {
                if (plane.userData.lat && plane.userData.lon) withPosition++;
            }
            const quality = altCount > 0 ? Math.round((withPosition / altCount) * 100) : 0;
            document.getElementById('stats-data-quality').textContent = quality + '%';

            // Update altitude distribution bars
            const maxBucket = Math.max(...altBuckets, 1);
            for (let i = 0; i < 5; i++) {
                const pct = (altBuckets[i] / maxBucket) * 100;
                document.getElementById(`alt-bar-${i}`).style.width = pct + '%';
                document.getElementById(`alt-count-${i}`).textContent = altBuckets[i];
            }

            // Update top aircraft types/airlines
            const sortedTypes = Array.from(aircraftTypeStats.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            const typesHtml = sortedTypes.map(([code, count]) =>
                `<div style="display:flex;justify-content:space-between;padding:2px 0;">
                    <span>${code}</span><span style="font-weight:bold;">${count}</span>
                </div>`
            ).join('');
            document.getElementById('top-aircraft-types').innerHTML = typesHtml || '<em>No data</em>';

            // Update speed distribution
            const speedBuckets = [0, 0, 0, 0]; // <150, 150-300, 300-450, >450
            const categoryStats = new Map();

            for (const plane of _airplanesArray) {
                const speed = plane.userData.gs || 0;
                const category = plane.userData.category || 'jet';

                // Speed buckets
                if (speed < 150) speedBuckets[0]++;
                else if (speed < 300) speedBuckets[1]++;
                else if (speed < 450) speedBuckets[2]++;
                else speedBuckets[3]++;

                // Category stats
                categoryStats.set(category, (categoryStats.get(category) || 0) + 1);
            }

            // Update speed distribution bars
            const maxSpeedBucket = Math.max(...speedBuckets, 1);
            for (let i = 0; i < 4; i++) {
                const el = document.getElementById(`spd-bar-${i}`);
                const countEl = document.getElementById(`spd-count-${i}`);
                if (el && countEl) {
                    const pct = (speedBuckets[i] / maxSpeedBucket) * 100;
                    el.style.width = pct + '%';
                    countEl.textContent = speedBuckets[i];
                }
            }

            // Update aircraft type chart
            const categoryNames = {
                'jet': 'Jets',
                'widebody': 'Wide-body',
                'regional': 'Regional',
                'small': 'Small/GA',
                'helicopter': 'Helicopters',
                'military': 'Military'
            };
            const sortedCategories = Array.from(categoryStats.entries())
                .sort((a, b) => b[1] - a[1]);
            const categoryHtml = sortedCategories.map(([cat, count]) =>
                `<div style="display:flex;justify-content:space-between;padding:2px 0;">
                    <span>${categoryNames[cat] || cat}</span><span style="font-weight:bold;">${count}</span>
                </div>`
            ).join('');
            const typeChartEl = document.getElementById('aircraft-type-chart');
            if (typeChartEl) {
                typeChartEl.innerHTML = categoryHtml || '<em>No data</em>';
            }

            // Draw coverage heatmap
            drawCoverageHeatmap();
        }

        function drawCoverageHeatmap() {
            const canvas = document.getElementById('coverage-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const cellW = rect.width / 20;
            const cellH = rect.height / 20;

            const isRetro = currentTheme === 'retro';
            const maxVal = Math.max(...coverageHeatmap, 1);

            for (let y = 0; y < 20; y++) {
                for (let x = 0; x < 20; x++) {
                    const val = coverageHeatmap[y * 20 + x];
                    const intensity = val / maxVal;

                    if (isRetro) {
                        ctx.fillStyle = `rgba(0, ${Math.floor(255 * intensity)}, 0, ${0.2 + intensity * 0.8})`;
                    } else if (currentTheme === 'night') {
                        ctx.fillStyle = `rgba(0, ${Math.floor(180 + 75 * intensity)}, ${Math.floor(255 * intensity)}, ${0.2 + intensity * 0.8})`;
                    } else {
                        ctx.fillStyle = `rgba(0, ${Math.floor(100 + 155 * intensity)}, ${Math.floor(255 * intensity)}, ${0.2 + intensity * 0.8})`;
                    }

                    ctx.fillRect(x * cellW, (19 - y) * cellH, cellW - 1, cellH - 1);
                }
            }
        }

        // ===========================================
        // AIRCRAFT INFORMATION ENRICHMENT
        // ===========================================
        async function checkEnrichmentApiAvailability() {
            // Try to check if we have internet access and can reach external APIs
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 3000);
                const response = await fetch('https://hexdb.io/api/v1/aircraft/a00001', {
                    method: 'HEAD',
                    signal: controller.signal
                });
                clearTimeout(timeout);
                enrichmentApiAvailable = response.ok;
            } catch (e) {
                enrichmentApiAvailable = false;
            }
            console.log('Aircraft enrichment API available:', enrichmentApiAvailable);
        }

        async function fetchAircraftInfo(hex) {
            if (!hex || enrichmentApiAvailable === false) return null;

            // Check cache first
            if (aircraftInfoCache.has(hex)) {
                return aircraftInfoCache.get(hex);
            }

            try {
                // Try hexdb.io API (free, no auth required)
                const response = await fetch(`https://hexdb.io/api/v1/aircraft/${hex}`, {
                    cache: 'force-cache'
                });

                if (response.ok) {
                    const data = await response.json();
                    const info = {
                        registration: data.Registration || null,
                        manufacturer: data.Manufacturer || null,
                        type: data.Type || null,
                        model: data.ICAOTypeCode || null,
                        operator: data.RegisteredOwners || null,
                        country: data.OperatorFlagCode || null,
                        origin: null,
                        destination: null
                    };
                    aircraftInfoCache.set(hex, info);
                    return info;
                }
            } catch (e) {
                // API not available
            }

            // Cache null result to avoid repeated failed requests
            aircraftInfoCache.set(hex, null);
            return null;
        }

        // Fetch route information from ADS-B Exchange or adsbdb
        async function fetchRouteInfo(callsign, hex) {
            if (!callsign && !hex) return null;

            const cacheKey = `route-${callsign || hex}`;
            if (aircraftInfoCache.has(cacheKey)) {
                return aircraftInfoCache.get(cacheKey);
            }

            // Try adsbdb.com for callsign-based route lookup
            if (callsign) {
                try {
                    const cleanCallsign = callsign.trim().toUpperCase();
                    const response = await fetch(`https://api.adsbdb.com/v0/callsign/${cleanCallsign}`, {
                        cache: 'force-cache'
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.response && data.response.flightroute) {
                            const route = data.response.flightroute;
                            const routeInfo = {
                                origin: route.origin ? `${route.origin.iata_code || route.origin.icao_code} - ${route.origin.name || ''}`.trim() : null,
                                originCode: route.origin ? (route.origin.iata_code || route.origin.icao_code) : null,
                                destination: route.destination ? `${route.destination.iata_code || route.destination.icao_code} - ${route.destination.name || ''}`.trim() : null,
                                destinationCode: route.destination ? (route.destination.iata_code || route.destination.icao_code) : null,
                                airline: route.airline ? route.airline.name : null
                            };
                            aircraftInfoCache.set(cacheKey, routeInfo);
                            return routeInfo;
                        }
                    }
                } catch (e) {
                    // adsbdb not available
                }
            }

            // Try ADS-B Exchange API as fallback
            if (hex) {
                try {
                    const response = await fetch(`https://api.adsb.lol/v2/hex/${hex}`, {
                        cache: 'no-store'
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.ac && data.ac.length > 0) {
                            const ac = data.ac[0];
                            // adsb.lol provides route in 'r' field sometimes
                            if (ac.flight) {
                                // Try to get route from the response
                                const routeInfo = {
                                    origin: ac.dep || null,
                                    originCode: ac.dep || null,
                                    destination: ac.arr || null,
                                    destinationCode: ac.arr || null,
                                    airline: null
                                };
                                if (routeInfo.origin || routeInfo.destination) {
                                    aircraftInfoCache.set(cacheKey, routeInfo);
                                    return routeInfo;
                                }
                            }
                        }
                    }
                } catch (e) {
                    // adsb.lol not available
                }
            }

            // Cache null to avoid repeated requests
            aircraftInfoCache.set(cacheKey, null);
            return null;
        }

        async function updateEnrichedInfo(plane) {
            const enrichedPanel = document.getElementById('aircraft-enriched-info');
            const loadingEl = document.getElementById('enriched-loading');
            const dataEl = document.getElementById('enriched-data');

            if (!plane || enrichmentApiAvailable === false) {
                enrichedPanel.classList.remove('visible');
                return;
            }

            enrichedPanel.classList.add('visible');
            loadingEl.style.display = 'block';
            dataEl.style.display = 'none';

            // Fetch aircraft info and route info in parallel
            const [info, routeInfo] = await Promise.all([
                fetchAircraftInfo(plane.userData.hex),
                fetchRouteInfo(plane.userData.flight, plane.userData.hex)
            ]);

            if (info || routeInfo) {
                document.getElementById('sel-registration').textContent = (info && info.registration) || '--';
                document.getElementById('sel-aircraft-type').textContent =
                    (info && [info.manufacturer, info.type].filter(Boolean).join(' ')) || '--';
                document.getElementById('sel-operator').textContent =
                    (routeInfo && routeInfo.airline) || (info && info.operator) || '--';
                document.getElementById('sel-origin').textContent =
                    (routeInfo && routeInfo.origin) || '--';
                document.getElementById('sel-destination').textContent =
                    (routeInfo && routeInfo.destination) || '--';

                // Update external links
                const callsign = plane.userData.flight || '';
                const hex = plane.userData.hex;
                document.getElementById('link-flightaware').href =
                    callsign ? `https://flightaware.com/live/flight/${callsign.trim()}` : '#';
                document.getElementById('link-fr24').href =
                    callsign ? `https://www.flightradar24.com/${callsign.trim()}` : '#';
                document.getElementById('link-adsbx').href =
                    hex ? `https://globe.adsbexchange.com/?icao=${hex}` : '#';

                loadingEl.style.display = 'none';
                dataEl.style.display = 'block';
            } else {
                // No data available, hide enriched panel
                enrichedPanel.classList.remove('visible');
            }
        }

        // ===========================================
        // AIRCRAFT TYPE DIFFERENTIATION
        // ===========================================
        // Determine aircraft category based on available data
        function getAircraftCategory(data) {
            const flight = (data.flight || '').trim().toUpperCase();
            const alt = data.altitude || 0;
            const speed = data.gs || 0;

            // Check for helicopter patterns (low altitude, low speed, specific callsigns)
            if (alt < 3000 && speed < 150) {
                if (flight.match(/^(N\d|LIFE|MED|HELI|COAST|RESCUE)/)) {
                    return 'helicopter';
                }
            }

            // Military patterns
            if (flight.match(/^(RCH|REACH|DUKE|EVAC|SPAR|EXEC|AIR|FORCE|NAVY|ARMY|TOPCAT|HAWK)/)) {
                return 'military';
            }

            // Small aircraft (low altitude, slow speed, GA callsigns)
            if (alt < 10000 && speed < 200) {
                if (flight.match(/^N\d/) || flight === '') {
                    return 'small';
                }
            }

            // Regional jets (medium altitude, medium speed)
            if (alt < 30000 && speed < 400) {
                return 'regional';
            }

            // Wide-body indicators (heavy suffix patterns, long-haul routes)
            if (flight.match(/(UAE|QTR|SIA|CPA|BAW|DLH|AFR|KLM|ANA|JAL)/)) {
                return 'widebody';
            }

            // Default to narrow-body jet
            return 'jet';
        }

        // Extended createAirplane function is handled in original - add category info to userData
        // We'll modify the existing function to include category

        // ===========================================
        // FEATURE 1: AIRCRAFT SEARCH & FILTER
        // ===========================================
        let searchQuery = '';
        let filterAltitude = '';
        let filterSpeed = '';
        let filterType = '';
        let filteredAircraft = new Set(); // Hex codes of aircraft matching filters

        window.toggleSearchPanel = function() {
            const panel = document.getElementById('search-panel');
            panel.classList.toggle('collapsed');
        };

        window.filterAircraft = function() {
            searchQuery = document.getElementById('search-input').value.trim().toUpperCase();
            filterAltitude = document.getElementById('filter-altitude').value;
            filterSpeed = document.getElementById('filter-speed').value;
            filterType = document.getElementById('filter-type').value;

            filteredAircraft.clear();
            let matchCount = 0;
            let totalCount = 0;

            for (const [hex, plane] of airplanes.entries()) {
                totalCount++;
                const data = plane.userData;
                let matches = true;

                // Search by callsign/hex
                if (searchQuery) {
                    const callsign = (data.flight || '').toUpperCase();
                    const hexCode = (data.hex || '').toUpperCase();
                    if (!callsign.includes(searchQuery) && !hexCode.includes(searchQuery)) {
                        matches = false;
                    }
                }

                // Filter by altitude
                if (matches && filterAltitude) {
                    const alt = data.altitude || 0;
                    if (filterAltitude === '0-5000' && (alt < 0 || alt >= 5000)) matches = false;
                    else if (filterAltitude === '5000-15000' && (alt < 5000 || alt >= 15000)) matches = false;
                    else if (filterAltitude === '15000-30000' && (alt < 15000 || alt >= 30000)) matches = false;
                    else if (filterAltitude === '30000-45000' && (alt < 30000 || alt >= 45000)) matches = false;
                    else if (filterAltitude === '45000+' && alt < 45000) matches = false;
                }

                // Filter by speed
                if (matches && filterSpeed) {
                    const speed = data.gs || 0;
                    if (filterSpeed === '0-150' && speed >= 150) matches = false;
                    else if (filterSpeed === '150-300' && (speed < 150 || speed >= 300)) matches = false;
                    else if (filterSpeed === '300-500' && (speed < 300 || speed >= 500)) matches = false;
                    else if (filterSpeed === '500+' && speed < 500) matches = false;
                }

                // Filter by aircraft type
                if (matches && filterType) {
                    const category = data.category || 'jet';
                    if (filterType !== category) matches = false;
                }

                // Apply visibility
                plane.visible = matches;
                if (plane.userData.trail) plane.userData.trail.visible = matches && trailEnabled;
                if (plane.userData.altLine) plane.userData.altLine.visible = matches;
                if (plane.userData.label) plane.userData.label.visible = matches && showLabels;
                if (plane.userData.predictionLine) plane.userData.predictionLine.visible = matches && showPrediction;

                if (matches) {
                    filteredAircraft.add(hex);
                    matchCount++;
                }
            }

            document.getElementById('search-results-count').textContent =
                (searchQuery || filterAltitude || filterSpeed || filterType)
                    ? `${matchCount}/${totalCount}`
                    : `${totalCount} shown`;

            _needsRender = true;
            updateLabels();
        };

        window.clearFilters = function() {
            document.getElementById('search-input').value = '';
            document.getElementById('filter-altitude').value = '';
            document.getElementById('filter-speed').value = '';
            document.getElementById('filter-type').value = '';
            filterAircraft();
        };

        // ===========================================
        // FEATURE 3: FLIGHT PATH PREDICTION
        // ===========================================
        let showPrediction = false;
        const PREDICTION_MINUTES = 5; // Predict 5 minutes ahead

        window.togglePrediction = function() {
            showPrediction = !showPrediction;
            document.getElementById('btn-prediction').classList.toggle('active', showPrediction);

            // Update all prediction lines
            for (const plane of airplanes.values()) {
                if (showPrediction) {
                    updatePredictionLine(plane);
                } else if (plane.userData.predictionLine) {
                    plane.userData.predictionLine.visible = false;
                }
            }
            _needsRender = true;
        };

        function createPredictionLine(plane) {
            if (plane.userData.predictionLine) return;

            const isRetro = currentTheme === 'retro';
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(6); // Start and end points
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.LineDashedMaterial({
                color: isRetro ? 0x00ffff : 0xff8800,
                dashSize: 3,
                gapSize: 2,
                transparent: true,
                opacity: 0.6
            });

            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            line.visible = false;
            scene.add(line);

            plane.userData.predictionLine = line;
        }

        function updatePredictionLine(plane) {
            if (!showPrediction) return;

            const data = plane.userData;
            if (!data.lat || !data.lon || !data.track || !data.gs) return;

            // Create prediction line if doesn't exist
            if (!plane.userData.predictionLine) {
                createPredictionLine(plane);
            }

            const line = plane.userData.predictionLine;
            const positions = line.geometry.attributes.position.array;

            // Current position
            const currentPos = latLonToXZ(data.lat, data.lon);
            const currentAlt = (data.altitude || 0) * altitudeScale;

            // Predict future position
            const speedKts = data.gs || 0;
            const speedNmPerMin = speedKts / 60;
            const distanceNm = speedNmPerMin * PREDICTION_MINUTES;

            // Convert track to radians (0 = North, clockwise)
            const trackRad = (data.track || 0) * Math.PI / 180;

            // Calculate lat/lon change
            const latChange = distanceNm * Math.cos(trackRad) / 60; // 1 degree = 60 nm approx
            const lonChange = distanceNm * Math.sin(trackRad) / (60 * Math.cos(data.lat * Math.PI / 180));

            const futureLat = data.lat + latChange;
            const futureLon = data.lon + lonChange;

            // Account for vertical rate
            const vertRate = data.baro_rate || 0; // ft/min
            const altChange = vertRate * PREDICTION_MINUTES;
            const futureAlt = Math.max(0, (data.altitude || 0) + altChange) * altitudeScale;

            const futurePos = latLonToXZ(futureLat, futureLon);

            // Update line geometry
            positions[0] = currentPos.x;
            positions[1] = currentAlt;
            positions[2] = currentPos.z;
            positions[3] = futurePos.x;
            positions[4] = futureAlt;
            positions[5] = futurePos.z;

            line.geometry.attributes.position.needsUpdate = true;
            line.computeLineDistances();
            line.visible = true;
        }

        // ===========================================
        // FEATURE 4: AIRCRAFT ALERTS
        // ===========================================
        let alertsEnabled = true;
        let alertedAircraft = new Set(); // Track which aircraft have already triggered alerts
        const ALERT_DURATION = 15000; // 15 seconds

        window.toggleAlerts = function() {
            alertsEnabled = !alertsEnabled;
            document.getElementById('btn-alerts').classList.toggle('active', alertsEnabled);
            if (!alertsEnabled) {
                document.getElementById('alert-container').innerHTML = '';
            }
        };

        function checkAircraftAlerts(plane) {
            if (!alertsEnabled) return;

            const data = plane.userData;
            const hex = data.hex;
            if (!hex || alertedAircraft.has(hex)) return;

            let alertType = null;
            let alertTitle = '';
            let alertDetails = '';
            let alertIcon = '';

            // Emergency squawk codes
            const squawk = data.squawk || '';
            if (squawk === '7500') {
                alertType = 'emergency';
                alertIcon = 'üö®';
                alertTitle = 'HIJACK ALERT (7500)';
                alertDetails = `${data.flight || hex} - Hijacking or unlawful interference`;
            } else if (squawk === '7600') {
                alertType = 'emergency';
                alertIcon = 'üìª';
                alertTitle = 'RADIO FAILURE (7600)';
                alertDetails = `${data.flight || hex} - Communication failure`;
            } else if (squawk === '7700') {
                alertType = 'emergency';
                alertIcon = '‚ö†Ô∏è';
                alertTitle = 'EMERGENCY (7700)';
                alertDetails = `${data.flight || hex} - General emergency`;
            }

            // Military aircraft
            if (!alertType && data.category === 'military') {
                alertType = 'military';
                alertIcon = 'üéñÔ∏è';
                alertTitle = 'Military Aircraft';
                alertDetails = `${data.flight || hex} - ${formatAltitude(data.altitude || 0)} @ ${formatSpeed(data.gs || 0)}`;
            }

            // Low altitude alert (below 1000ft and moving)
            if (!alertType && data.altitude && data.altitude < 1000 && data.gs > 50) {
                alertType = 'lowalt';
                alertIcon = '‚¨áÔ∏è';
                alertTitle = 'Low Altitude Aircraft';
                alertDetails = `${data.flight || hex} at ${formatAltitude(data.altitude)}`;
            }

            if (alertType) {
                showAlert(alertType, alertIcon, alertTitle, alertDetails, hex);
                alertedAircraft.add(hex);

                // Remove from alerted set after delay to allow re-alerting
                setTimeout(() => alertedAircraft.delete(hex), 60000);
            }
        }

        function showAlert(type, icon, title, details, hex) {
            const container = document.getElementById('alert-container');
            const alert = document.createElement('div');
            alert.className = `alert-notification alert-${type}`;
            alert.innerHTML = `
                <span class="alert-icon">${icon}</span>
                <span class="alert-title">${title}</span>
                <div class="alert-details">${details}</div>
            `;

            alert.onclick = () => {
                // Select and follow the aircraft
                const plane = airplanes.get(hex);
                if (plane) {
                    selectPlane(plane);
                    followSelectedPlane = true;
                }
                alert.remove();
            };

            container.appendChild(alert);

            // Auto-remove after duration
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.style.animation = 'slideIn 0.3s ease reverse';
                    setTimeout(() => alert.remove(), 300);
                }
            }, ALERT_DURATION);
        }

        // ===========================================
        // FEATURE 6: AIRPORT MARKERS
        // ===========================================
        let showAirports = false;
        let airportMarkers = [];
        const nearbyAirports = new Map(); // Cached airports by location

        // Major airports database (subset - can be expanded)
        const AIRPORT_DATABASE = [
            { icao: 'KJFK', iata: 'JFK', name: 'John F Kennedy Intl', lat: 40.6413, lon: -73.7781 },
            { icao: 'KLAX', iata: 'LAX', name: 'Los Angeles Intl', lat: 33.9425, lon: -118.4081 },
            { icao: 'KORD', iata: 'ORD', name: "Chicago O'Hare", lat: 41.9742, lon: -87.9073 },
            { icao: 'KATL', iata: 'ATL', name: 'Hartsfield-Jackson Atlanta', lat: 33.6407, lon: -84.4277 },
            { icao: 'KDFW', iata: 'DFW', name: 'Dallas/Fort Worth', lat: 32.8998, lon: -97.0403 },
            { icao: 'KDEN', iata: 'DEN', name: 'Denver Intl', lat: 39.8561, lon: -104.6737 },
            { icao: 'KSFO', iata: 'SFO', name: 'San Francisco Intl', lat: 37.6213, lon: -122.3790 },
            { icao: 'KSEA', iata: 'SEA', name: 'Seattle-Tacoma', lat: 47.4502, lon: -122.3088 },
            { icao: 'KMIA', iata: 'MIA', name: 'Miami Intl', lat: 25.7959, lon: -80.2870 },
            { icao: 'KBOS', iata: 'BOS', name: 'Boston Logan', lat: 42.3656, lon: -71.0096 },
            { icao: 'EGLL', iata: 'LHR', name: 'London Heathrow', lat: 51.4700, lon: -0.4543 },
            { icao: 'EGKK', iata: 'LGW', name: 'London Gatwick', lat: 51.1537, lon: -0.1821 },
            { icao: 'LFPG', iata: 'CDG', name: 'Paris Charles de Gaulle', lat: 49.0097, lon: 2.5479 },
            { icao: 'EDDF', iata: 'FRA', name: 'Frankfurt', lat: 50.0379, lon: 8.5622 },
            { icao: 'EHAM', iata: 'AMS', name: 'Amsterdam Schiphol', lat: 52.3105, lon: 4.7683 },
            { icao: 'LEMD', iata: 'MAD', name: 'Madrid Barajas', lat: 40.4983, lon: -3.5676 },
            { icao: 'RJTT', iata: 'HND', name: 'Tokyo Haneda', lat: 35.5494, lon: 139.7798 },
            { icao: 'RJAA', iata: 'NRT', name: 'Tokyo Narita', lat: 35.7720, lon: 140.3929 },
            { icao: 'VHHH', iata: 'HKG', name: 'Hong Kong Intl', lat: 22.3080, lon: 113.9185 },
            { icao: 'WSSS', iata: 'SIN', name: 'Singapore Changi', lat: 1.3644, lon: 103.9915 },
            { icao: 'OMDB', iata: 'DXB', name: 'Dubai Intl', lat: 25.2532, lon: 55.3657 },
            { icao: 'YSSY', iata: 'SYD', name: 'Sydney Kingsford Smith', lat: -33.9399, lon: 151.1753 },
            { icao: 'ZBAA', iata: 'PEK', name: 'Beijing Capital', lat: 40.0799, lon: 116.6031 },
            { icao: 'ZSPD', iata: 'PVG', name: 'Shanghai Pudong', lat: 31.1443, lon: 121.8083 },
            { icao: 'VIDP', iata: 'DEL', name: 'Indira Gandhi Intl', lat: 28.5562, lon: 77.1000 },
            { icao: 'CYYZ', iata: 'YYZ', name: 'Toronto Pearson', lat: 43.6777, lon: -79.6248 },
            { icao: 'CYMX', iata: 'YUL', name: 'Montreal Trudeau', lat: 45.4706, lon: -73.7408 },
            { icao: 'SBGR', iata: 'GRU', name: 'Sao Paulo Guarulhos', lat: -23.4356, lon: -46.4731 },
            { icao: 'MMMX', iata: 'MEX', name: 'Mexico City Intl', lat: 19.4363, lon: -99.0721 },
        ];

        window.toggleAirports = function() {
            showAirports = !showAirports;
            document.getElementById('btn-airports').classList.toggle('active', showAirports);

            if (showAirports) {
                updateAirportMarkers();
            } else {
                clearAirportMarkers();
            }
            _needsRender = true;
        };

        function clearAirportMarkers() {
            for (const marker of airportMarkers) {
                scene.remove(marker);
                if (marker.userData.label) scene.remove(marker.userData.label);
            }
            airportMarkers = [];
        }

        function updateAirportMarkers() {
            clearAirportMarkers();
            if (!showAirports || !centerInitialized) return;

            const isRetro = currentTheme === 'retro';

            // Find airports within view radius
            for (const airport of AIRPORT_DATABASE) {
                const distance = haversineDistance(centerLat, centerLon, airport.lat, airport.lon);
                if (distance <= viewRadius) {
                    createAirportMarker(airport, isRetro);
                }
            }
        }

        function createAirportMarker(airport, isRetro) {
            const pos = latLonToXZ(airport.lat, airport.lon);

            // Create runway marker
            const geometry = new THREE.BoxGeometry(4, 0.5, 15);
            const material = new THREE.MeshBasicMaterial({
                color: isRetro ? 0x00ff00 : 0x333333,
                transparent: true,
                opacity: 0.8
            });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(pos.x, 0.3, pos.z);
            marker.userData = { airport: airport };
            scene.add(marker);
            airportMarkers.push(marker);

            // Create label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = isRetro ? '#00ff00' : '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(airport.iata, 128, 28);
            ctx.font = '14px Arial';
            ctx.fillText(airport.name.substring(0, 20), 128, 50);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const label = new THREE.Sprite(spriteMaterial);
            label.scale.set(20, 5, 1);
            label.position.set(pos.x, 5, pos.z);
            scene.add(label);
            marker.userData.label = label;
            airportMarkers.push(label);
        }

        // Haversine distance in nautical miles
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 3440.065; // Earth's radius in nm
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // ===========================================
        // FEATURE 10: EXPORT DATA
        // ===========================================
        let flightHistory = []; // Track all flights seen
        const MAX_HISTORY = 1000;

        window.toggleExportPanel = function() {
            const panel = document.getElementById('export-panel');
            panel.classList.toggle('visible');
        };

        window.exportToCSV = function() {
            const rows = [['Hex', 'Callsign', 'Latitude', 'Longitude', 'Altitude (ft)', 'Speed (kts)', 'Track', 'Squawk', 'Type', 'Timestamp']];

            for (const plane of airplanes.values()) {
                const d = plane.userData;
                rows.push([
                    d.hex || '',
                    d.flight || '',
                    (d.lat || 0).toFixed(6),
                    (d.lon || 0).toFixed(6),
                    Math.round(d.altitude || 0),
                    Math.round(d.gs || 0),
                    Math.round(d.track || 0),
                    d.squawk || '',
                    d.category || '',
                    new Date().toISOString()
                ]);
            }

            const csv = rows.map(r => r.join(',')).join('\n');
            downloadFile(csv, `flight-data-${Date.now()}.csv`, 'text/csv');
            toggleExportPanel();
        };

        window.exportToJSON = function() {
            const data = {
                timestamp: new Date().toISOString(),
                location: { lat: viewLatitude, lon: viewLongitude, radius: viewRadius },
                aircraft: []
            };

            for (const plane of airplanes.values()) {
                const d = plane.userData;
                data.aircraft.push({
                    hex: d.hex,
                    callsign: d.flight,
                    position: { lat: d.lat, lon: d.lon },
                    altitude: d.altitude,
                    speed: d.gs,
                    track: d.track,
                    verticalRate: d.baro_rate,
                    squawk: d.squawk,
                    category: d.category,
                    registration: d.registration
                });
            }

            const json = JSON.stringify(data, null, 2);
            downloadFile(json, `flight-data-${Date.now()}.json`, 'application/json');
            toggleExportPanel();
        };

        window.exportFlightHistory = function() {
            const data = {
                exportTime: new Date().toISOString(),
                totalFlights: flightHistory.length,
                flights: flightHistory
            };

            const json = JSON.stringify(data, null, 2);
            downloadFile(json, `flight-history-${Date.now()}.json`, 'application/json');
            toggleExportPanel();
        };

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Track flights for history
        function recordFlightHistory(plane) {
            const d = plane.userData;
            if (!d.hex) return;

            // Check if already recorded recently
            const existing = flightHistory.find(f => f.hex === d.hex && Date.now() - f.lastSeen < 60000);
            if (existing) {
                existing.lastSeen = Date.now();
                existing.positions.push({ lat: d.lat, lon: d.lon, alt: d.altitude, time: Date.now() });
                if (existing.positions.length > 100) existing.positions.shift();
                return;
            }

            // New flight record
            flightHistory.push({
                hex: d.hex,
                callsign: d.flight,
                firstSeen: Date.now(),
                lastSeen: Date.now(),
                positions: [{ lat: d.lat, lon: d.lon, alt: d.altitude, time: Date.now() }],
                maxAltitude: d.altitude || 0,
                maxSpeed: d.gs || 0,
                category: d.category
            });

            // Limit history size
            if (flightHistory.length > MAX_HISTORY) {
                flightHistory.shift();
            }
        }

        // ===========================================
        // FEATURE 12: CUSTOM MAP TILE LAYERS
        // ===========================================
        let customTileUrl = '';
        const TILE_PRESETS = {
            'osm': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            'carto-dark': 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
            'carto-light': 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            'stamen-terrain': 'https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png',
            'esri-sat': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
        };

        window.toggleTilePanel = function() {
            const panel = document.getElementById('tile-layer-panel');
            panel.classList.toggle('visible');
        };

        window.setTilePreset = function(preset) {
            document.getElementById('custom-tile-url').value = TILE_PRESETS[preset] || '';
        };

        window.applyCustomTiles = function() {
            customTileUrl = document.getElementById('custom-tile-url').value.trim();
            if (customTileUrl) {
                // Clear tile cache
                tileCache.clear();
                // Reload tiles with custom URL
                loadMapTiles();
            }
            toggleTilePanel();
        };

        // Override getTileUrl when custom tiles are set
        const originalGetTileUrl = getTileUrl;
        function getCustomTileUrl(x, y, zoom) {
            if (!customTileUrl) {
                return originalGetTileUrl(x, y, zoom);
            }

            // Support both {z}/{x}/{y} and {zoom}/{x}/{y} placeholders
            let url = customTileUrl
                .replace('{z}', zoom)
                .replace('{zoom}', zoom)
                .replace('{x}', x)
                .replace('{y}', y);

            // Handle {s} subdomain placeholder
            if (url.includes('{s}')) {
                const subdomains = ['a', 'b', 'c'];
                const subdomain = subdomains[Math.abs(x + y) % 3];
                url = url.replace('{s}', subdomain);
            }

            return url;
        }

        // Monkey-patch getTileUrl
        window.getTileUrl = getCustomTileUrl;

        // ===========================================
        // FEATURE 7: CAMERA FOLLOW MODES (STANDARD / CHASE / COCKPIT / ORBIT)
        // ===========================================
        let cameraFollowMode = 'standard'; // 'standard' (map-center only), 'chase', 'cockpit', 'cinematic'
        let cinematicAngle = 0;
        const BASE_CINEMATIC_DISTANCE = 80;
        const BASE_CINEMATIC_HEIGHT = 30;
        const BASE_CHASE_DIST = 60;
        const BASE_CHASE_HEIGHT = 20;
        const BASE_COCKPIT_NOSE = 8;
        const BASE_COCKPIT_HEIGHT = 3;
        let followZoom = 1; // wheel-adjustable zoom for follow modes

        function updateFollowCamera() {
            if (!followSelectedPlane || !selectedPlane) return;
            const plane = airplanes.get(selectedPlane.userData.hex);
            if (!plane) return;

            const trackDeg = plane.userData.track || 0;
            const t = trackDeg * Math.PI / 180;
            // Forward vector from track: 0¬∞ = North ‚Üí z negative
            const fwdX = Math.sin(t), fwdZ = -Math.cos(t);

            if (cameraFollowMode === 'chase') {
                const dist = BASE_CHASE_DIST * followZoom;
                const height = BASE_CHASE_HEIGHT * followZoom;
                const targetX = plane.position.x - fwdX * dist;
                const targetZ = plane.position.z - fwdZ * dist;
                const targetY = plane.position.y + height;

                camera.position.x += (targetX - camera.position.x) * 0.15;
                camera.position.y += (targetY - camera.position.y) * 0.15;
                camera.position.z += (targetZ - camera.position.z) * 0.15;
                camera.lookAt(plane.position.x + fwdX * 20, plane.position.y, plane.position.z + fwdZ * 20);
                _needsRender = true;
            } else if (cameraFollowMode === 'cockpit') {
                const nose = BASE_COCKPIT_NOSE * followZoom; // forward offset from center
                const height = BASE_COCKPIT_HEIGHT * followZoom; // slight upward offset
                const camX = plane.position.x + fwdX * nose;
                const camZ = plane.position.z + fwdZ * nose;
                const camY = plane.position.y + height;

                camera.position.x += (camX - camera.position.x) * 0.2;
                camera.position.y += (camY - camera.position.y) * 0.2;
                camera.position.z += (camZ - camera.position.z) * 0.2;
                // Look far ahead in flight direction
                camera.lookAt(camX + fwdX * 200, camY, camZ + fwdZ * 200);
                _needsRender = true;
            } else if (cameraFollowMode === 'cinematic') {
                // Smooth orbit around aircraft
                cinematicAngle += 0.005;
                const dist = BASE_CINEMATIC_DISTANCE * followZoom;
                const height = BASE_CINEMATIC_HEIGHT * followZoom;
                const targetX = plane.position.x + Math.sin(cinematicAngle) * dist;
                const targetZ = plane.position.z + Math.cos(cinematicAngle) * dist;
                const targetY = plane.position.y + height;

                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.position.z += (targetZ - camera.position.z) * 0.05;
                camera.lookAt(plane.position);
                _needsRender = true;
            } else {
                // 'standard' mode keeps default orbit camera; no changes here
            }
        }

        // Public helpers for follow mode via UI
        window.enableFollow = function(mode) {
            cameraFollowMode = mode || 'standard';
            followSelectedPlane = !!selectedPlane;
            updateFollowButtons();
        };
        window.disableFollow = function() {
            followSelectedPlane = false;
            updateFollowButtons();
        };
        function updateFollowButtons() {
            const modes = ['follow','chase','cockpit','cinematic','unfollow'];
            modes.forEach(id => document.getElementById(`btn-${id}`)?.classList.remove('active'));
            if (followSelectedPlane) {
                const map = { standard: 'follow', chase: 'chase', cockpit: 'cockpit', cinematic: 'cinematic' };
                const btnId = map[cameraFollowMode] || 'follow';
                document.getElementById(`btn-${btnId}`)?.classList.add('active');
            } else {
                document.getElementById('btn-unfollow')?.classList.add('active');
            }
        }

        // ===========================================
        // FEATURE 9: MOBILE CONTROLS
        // ===========================================
        let mobileControlsVisible = false;

        window.toggleMobileControls = function() {
            mobileControlsVisible = !mobileControlsVisible;
            const controls = document.getElementById('controls');
            const toggle = document.getElementById('mobile-toggle');

            controls.classList.toggle('mobile-visible', mobileControlsVisible);
            toggle.textContent = mobileControlsVisible ? '‚úñÔ∏è' : '‚öôÔ∏è';
        };

        // Auto-hide mobile controls when clicking outside
        document.addEventListener('click', function(e) {
            if (window.innerWidth <= 768 && mobileControlsVisible) {
                const controls = document.getElementById('controls');
                const toggle = document.getElementById('mobile-toggle');
                if (!controls.contains(e.target) && e.target !== toggle) {
                    toggleMobileControls();
                }
            }
        });

        // ===========================================
        // FEATURE 8: IMPROVED LABELS
        // ===========================================
        // Enhanced label rendering with more info
        function renderEnhancedLabel(ctx, plane) {
            const canvas = ctx.canvas;
            const isRetro = currentTheme === 'retro';
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Background
            if (isRetro) {
                ctx.fillStyle = 'rgba(0, 20, 0, 0.85)';
            } else if (currentTheme === 'night') {
                ctx.fillStyle = 'rgba(0, 20, 40, 0.85)';
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            }
            ctx.beginPath();
            ctx.roundRect(2, 2, width - 4, height - 4, 8);
            ctx.fill();

            // Border
            ctx.strokeStyle = isRetro ? '#00ff00' : (currentTheme === 'night' ? '#0088ff' : '#0066cc');
            ctx.lineWidth = 2;
            ctx.stroke();

            // Text color
            ctx.fillStyle = isRetro ? '#00ff00' : (currentTheme === 'night' ? '#ffffff' : '#333333');

            // Callsign (large, top)
            const callsign = plane.userData.flight || plane.userData.hex || '?';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(callsign.trim(), width / 2, 35);

            // Speed and altitude (bottom row)
            const alt = formatAltitude(plane.userData.altitude || 0);
            const speed = formatSpeed(plane.userData.gs || 0);
            ctx.font = '18px Arial';
            ctx.fillText(`${alt} | ${speed}`, width / 2, 60);

            // Category indicator (small icon)
            const category = plane.userData.category || 'jet';
            const categoryIcons = {
                'helicopter': 'üöÅ',
                'military': 'üéñÔ∏è',
                'widebody': 'üõ´',
                'small': '‚úàÔ∏è',
                'regional': 'üõ©Ô∏è',
                'jet': '‚úàÔ∏è'
            };
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(categoryIcons[category] || '‚úàÔ∏è', 8, 22);

            // Squawk alert indicator
            const squawk = plane.userData.squawk || '';
            if (['7500', '7600', '7700'].includes(squawk)) {
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('‚ö†Ô∏è ' + squawk, width - 8, 22);
            }
        }

        // ===========================================
        // FOLLOW AIRCRAFT FEATURE
        // ===========================================
        function updateFollowMode() {
            if (!followSelectedPlane || !selectedPlane) return;

            const plane = airplanes.get(selectedPlane.userData.hex);
            if (!plane) {
                followSelectedPlane = false;
                return;
            }

            // Center map on selected aircraft
            if (plane.userData.lat && plane.userData.lon) {
                const targetLat = plane.userData.lat;
                const targetLon = plane.userData.lon;

                // Smooth transition if not already transitioning
                if (!mapTransition.active) {
                    const distLat = Math.abs(centerLat - targetLat);
                    const distLon = Math.abs(centerLon - targetLon);

                    // Only transition if aircraft moved significantly
                    if (distLat > 0.01 || distLon > 0.01) {
                        startMapTransition(targetLat, targetLon, currentZoom);
                    }
                }
            }
        }

        // Initialize
        init();

        // Check enrichment API availability on load
        checkEnrichmentApiAvailability();

        // Set button states based on loaded settings
        document.getElementById('btn-labels').classList.toggle('active', showLabels);
        document.getElementById('btn-rotate').classList.toggle('active', autoRotate);
        document.getElementById('btn-trails').classList.toggle('active', trailEnabled);
        document.getElementById('btn-graphs').classList.toggle('active', showGraphs);
        document.getElementById('btn-stats').classList.toggle('active', showStats);

        // Initialize stats panel update interval
        setInterval(() => {
            if (showStats) updateStatsPanel();
        }, 2000);
    </script>
</body>
</html>
